<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VolatilX - Action Center</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body class="action-center-page" data-live-price="{{ 'true' if live_price_enabled else 'false' }}">
    <div class="header">
        <a class="logo" href="/analyze">
            <img src="/static/VolatilX_Logo.PNG" alt="VolatilX Logo">
            <span>VolatilX</span>
        </a>
        <div class="nav-links">
            <a href="/analyze">AI Insights</a>
            <a href="/action-center" class="active">Action Center</a>
            <a href="/report-center">Report Center</a>
            <a href="/subscribe">Plans</a>
            <a href="/settings">Settings</a>
            <span>{{ user.email }}</span>
            <a href="/logout">Logout</a>
        </div>
    </div>

    <main class="action-center">
        <header class="action-center__header">
            <div>
                <h1>Action Center</h1>
                <p>Your AI-powered trading cockpit &mdash; real-time signals, levels, and actions.</p>
                {% if action_data %}
                <p class="action-center__meta">Symbol <strong>{{ action_data.symbol }}</strong>{% if action_data.generated_display %} &middot; Updated {{ action_data.generated_display }}{% endif %}</p>
                {% endif %}
            </div>
            <form class="action-controls" method="get" action="/action-center">
                <input type="hidden" name="symbol" value="{{ symbol }}">
                <label class="control-group">
                    <span>Timeframe</span>
                    <select name="timeframe" aria-label="Select timeframe">
                        <option value="day"{% if timeframe == 'day' %} selected{% endif %}>Day</option>
                        <option value="swing"{% if timeframe == 'swing' %} selected{% endif %}>Swing</option>
                        <option value="long"{% if timeframe == 'long' %} selected{% endif %}>Long</option>
                    </select>
                </label>
                <label class="control-group">
                    <span>Intent</span>
                    <select name="intent" aria-label="Select intent">
                        <option value="buy"{% if intent == 'buy' %} selected{% endif %}>Buy</option>
                        <option value="sell"{% if intent == 'sell' %} selected{% endif %}>Sell</option>
                    </select>
                </label>
                <button type="submit" class="pill-button">Update View</button>
                <button
                    type="button"
                    class="pill-button pill-button--ghost{% if is_favorited %} pill-button--active{% endif %}"
                    id="favoriteSymbol"
                    data-symbol="{{ symbol }}"
                    aria-pressed="{{ 'true' if is_favorited else 'false' }}"
                >
                    {{ 'Following' if is_favorited else 'Follow Symbol' }}
                </button>
                <label class="toggle" for="autoRefreshToggle">
                    <input type="checkbox" id="autoRefreshToggle" name="autoupdate" value="1">
                    <span>Auto-update</span>
                </label>
            </form>
        </header>

        {% if error_message %}
        <div class="action-center__empty">
            <p>{{ error_message }}</p>
        </div>
        {% endif %}

        {% if action_data %}
        <section class="action-card" data-section="primary">
            <div class="action-card__label">What should I do?</div>
            <div class="action-card__body">
                <div class="action-card__status action-card__status--{{ action_data.primary_action.icon }}">
                    <span class="action-card__status-title">{{ action_data.primary_action.title }}</span>
                    <span class="action-card__status-subtitle">{{ action_data.primary_action.subtitle }}</span>
                </div>
                <div class="action-card__details">
                    {% for line in action_data.primary_action.explanation %}
                    <p>{{ line }}</p>
                    {% endfor %}
                </div>
                <div class="confidence-meter" data-confidence="{{ action_data.primary_action.confidence_score }}">
                    <div class="confidence-meter__label">Confidence {{ action_data.primary_action.confidence }}</div>
                    <div class="confidence-meter__bar"><span data-confidence-bar data-width="{{ action_data.primary_action.confidence_score }}"></span></div>
                </div>
            </div>
        </section>

        <section class="gauge-cluster">
            <div class="gauge" data-gauge="bias" style="--gauge-value: {{ action_data.gauges.bias.score }}">
                <div class="gauge__dial"></div>
                <div class="gauge__content">
                    <span class="gauge__label">Bias</span>
                    <strong>{{ action_data.gauges.bias.label }}</strong>
                </div>
            </div>
            <div class="gauge" data-gauge="volatility" style="--gauge-value: {{ action_data.gauges.volatility.score }}">
                <div class="gauge__dial"></div>
                <div class="gauge__content">
                    <span class="gauge__label">Volatility</span>
                    <strong>{{ action_data.gauges.volatility.label }}</strong>
                </div>
            </div>
            <div class="gauge" data-gauge="signal" style="--gauge-value: {{ action_data.gauges.signal.score }}">
                <div class="gauge__dial"></div>
                <div class="gauge__content">
                    <span class="gauge__label">Signal Strength</span>
                    <strong>{{ action_data.gauges.signal.label }}</strong>
                </div>
            </div>
        </section>

        <section class="level-radar" aria-label="Support and resistance radar">
            <div class="level-radar__track" style="--price-position: {{ action_data.radar.price.position or 0.5 }}">
                <div class="level-marker level-marker--s2">
                    <span class="level-marker__title">Support-2</span>
                    <span class="level-marker__value">{{ action_data.radar.s2.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.s2.distance or '' }}</span>
                </div>
                <div class="level-marker level-marker--s1">
                    <span class="level-marker__title">Support-1</span>
                    <span class="level-marker__value">{{ action_data.radar.s1.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.s1.distance or '' }}</span>
                </div>
                <div class="level-marker level-marker--price">
                    <span class="level-marker__title">Price</span>
                    <span class="level-marker__value">{{ action_data.radar.price.value or 'N/A' }}</span>
                </div>
                <div class="level-marker level-marker--r1">
                    <span class="level-marker__title">Resistance-1</span>
                    <span class="level-marker__value">{{ action_data.radar.r1.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.r1.distance or '' }}</span>
                </div>
                <div class="level-marker level-marker--r2">
                    <span class="level-marker__title">Resistance-2</span>
                    <span class="level-marker__value">{{ action_data.radar.r2.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.r2.distance or '' }}</span>
                </div>
            </div>
            <div class="traffic-light traffic-light--{{ action_data.traffic_light }}" aria-label="Market zone indicator"></div>
        </section>

        <section class="scenario-cards">
            {% for scenario in action_data.scenarios %}
            <article class="scenario-card scenario-card--{{ scenario.icon }}">
                <h3>{{ scenario.title }}</h3>
                <p>{{ scenario.body }}</p>
            </article>
            {% endfor %}
        </section>

        <section class="trade-plan">
            <header>
                <h2>Auto-generated trade plan</h2>
                {% if strategy_summary %}
                <p>{{ strategy_summary }}</p>
                {% endif %}
            </header>
            <div class="trade-plan__grid">
                <div>
                    <h3>Entries</h3>
                    <ul>
                        <li><span>Initial</span><strong data-entry-field="primary">{{ action_data.trade_plan.entry.primary or 'N/A' }}</strong></li>
                        <li><span>Scale</span><strong data-entry-field="scale">{{ action_data.trade_plan.entry.scale or 'N/A' }}</strong></li>
                        <li><span>Breakout</span><strong data-entry-field="breakout">{{ action_data.trade_plan.entry.breakout or 'N/A' }}</strong></li>
                    </ul>
                </div>
                <div>
                    <h3>Targets</h3>
                    <ul data-plan-targets>
                        {% for target in action_data.trade_plan.targets %}
                        <li><strong>{{ target }}</strong></li>
                        {% endfor %}
                        {% if not action_data.trade_plan.targets %}
                        <li><strong>N/A</strong></li>
                        {% endif %}
                    </ul>
                </div>
                <div>
                    <h3>Stops</h3>
                    <ul data-plan-stops>
                        {% for stop in action_data.trade_plan.stops %}
                        <li><strong>{{ stop }}</strong></li>
                        {% endfor %}
                        {% if not action_data.trade_plan.stops %}
                        <li><strong>N/A</strong></li>
                        {% endif %}
                    </ul>
                </div>
                <div>
                    <h3>Position Size</h3>
                    <p class="trade-plan__size" data-plan-size>{{ action_data.trade_plan.position_size }}</p>
                    <h3>Risk Notes</h3>
                    <ul data-plan-risk>
                        {% for note in action_data.trade_plan.risk_notes %}
                        <li>{{ note }}</li>
                        {% endfor %}
                        {% if not action_data.trade_plan.risk_notes %}
                        <li>No additional risk notes.</li>
                        {% endif %}
                    </ul>
                </div>
            </div>
        </section>

        <section class="action-lower">
            <div class="alerts">
                <h2>Suggested alerts</h2>
                <ul>
                    {% for alert in action_data.alerts %}
                    <li><button type="button" class="alert-button" data-alert="{{ alert }}">{{ alert }}</button></li>
                    {% endfor %}
                    {% if not action_data.alerts %}
                    <li>No alerts suggested.</li>
                    {% endif %}
                </ul>
            </div>
            <div class="level-gauge" aria-label="Support and resistance luxury gauge">
                <div class="level-gauge__header">
                    <h2>Price range gauge</h2>
                    <span class="level-gauge__range" data-gauge-range>
                        {% set gauge_min = action_data.radar.s2.value if action_data.radar.s2.value else action_data.radar.s1.value %}
                        {% set gauge_max = action_data.radar.r2.value if action_data.radar.r2.value else action_data.radar.r1.value %}
                        {{ gauge_min or 'N/A' }} &ndash; {{ gauge_max or 'N/A' }}
                    </span>
                </div>
                <div class="level-gauge__body">
                    <canvas
                        class="level-gauge__canvas"
                        width="320"
                        height="160"
                        data-gauge-canvas
                        role="img"
                        aria-label="Price gauge"
                    ></canvas>
                    <div class="level-gauge__needle-value" data-gauge-price>{{ action_data.radar.price.value or action_data.latest_price or 'N/A' }}</div>
                </div>
            </div>
        </section>

        <footer class="action-tags">
            {% for tag in action_data.tags %}
            <span>{{ tag }}</span>
            {% endfor %}
        </footer>
        {% endif %}
    </main>

    {% if action_data_json %}
    <script id="actionCenterData" type="application/json">{{ action_data_json | safe }}</script>
    {% endif %}
    <script>
    (function() {
        const dataElement = document.getElementById('actionCenterData');
        let state = null;
        if (dataElement) {
            try {
                state = JSON.parse(dataElement.textContent || '{}');
            } catch (error) {
                console.warn('Failed to parse Action Center data payload', error);
            }
        }

        const autoToggle = document.getElementById('autoRefreshToggle');
        const favoriteButton = document.getElementById('favoriteSymbol');
        const defaultSymbol = '{{ symbol }}';
        const livePriceEnabled = document.body.getAttribute('data-live-price') === 'true';
        let refreshTimer = null;
        let livePriceTimer = null;
        let favoriteState = favoriteButton ? favoriteButton.getAttribute('aria-pressed') === 'true' : false;
        const gaugeCanvas = document.querySelector('[data-gauge-canvas]');
        const gaugeRange = document.querySelector('[data-gauge-range]');
        const gaugePriceValue = document.querySelector('[data-gauge-price]');
        const gaugeColors = {
            belowS2: '#3b0f14',
            betweenSupports: '#7f1d1d',
            midZone: '#b45309',
            betweenResistances: '#0f766e',
            aboveR2: '#064e3b',
        };
        let gaugeResizeTimer = null;
        const gaugeZoneFill = {
            belowS2: 'rgba(59, 15, 20, 0.5)',
            betweenSupports: 'rgba(127, 29, 29, 0.42)',
            midZone: 'rgba(180, 83, 9, 0.38)',
            betweenResistances: 'rgba(15, 118, 110, 0.38)',
            aboveR2: 'rgba(6, 78, 59, 0.4)',
        };
        const gaugeZoneLabels = {
            belowS2: 'below Support-2',
            betweenSupports: 'between Support-2 and Support-1',
            midZone: 'between Support-1 and Resistance-1',
            betweenResistances: 'between Resistance-1 and Resistance-2',
            aboveR2: 'above Resistance-2',
        };
        const degToRad = (deg) => (deg * Math.PI) / 180;
        const isFiniteNumber = (value) => typeof value === 'number' && Number.isFinite(value);

        function updateFavoriteButton(isActive) {
            if (!favoriteButton) return;
            favoriteButton.setAttribute('aria-pressed', String(isActive));
            favoriteButton.classList.toggle('pill-button--active', isActive);
            favoriteButton.textContent = isActive ? 'Following' : 'Follow Symbol';
        }

        function applyGaugeStyles() {
            document.querySelectorAll('.gauge').forEach((gauge) => {
                const value = gauge.getAttribute('data-live-value') || gauge.style.getPropertyValue('--gauge-value');
                if (value) {
                    gauge.style.setProperty('--gauge-value', value);
                }
            });
        }

        function applyConfidenceBar() {
            document.querySelectorAll('[data-confidence-bar]').forEach((node) => {
                const width = Number(node.dataset.width || 0);
                const clamped = Math.max(0, Math.min(width, 100));
                node.style.width = `${clamped}%`;
            });
        }

        function formatPrice(value) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return null;
            }
            return value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function parseNumeric(value) {
            if (typeof value === 'number') {
                return Number.isFinite(value) ? value : null;
            }
            if (typeof value === 'string') {
                const cleaned = value.replace(/,/g, '').trim();
                if (!cleaned) {
                    return null;
                }
                const parsed = Number(cleaned);
                return Number.isFinite(parsed) ? parsed : null;
            }
            return null;
        }

        function buildGaugeConfig(payload) {
            if (!payload) {
                return null;
            }

            const radar = payload.radar || {};
            const values = {
                s2: parseNumeric(radar.s2 && radar.s2.value),
                s1: parseNumeric(radar.s1 && radar.s1.value),
                r1: parseNumeric(radar.r1 && radar.r1.value),
                r2: parseNumeric(radar.r2 && radar.r2.value),
                price:
                    typeof payload.latest_price_value === 'number' && Number.isFinite(payload.latest_price_value)
                        ? payload.latest_price_value
                        : parseNumeric(radar.price && radar.price.value),
            };

            const anchors = {
                min: Math.PI,
                s2: degToRad(152.5),
                s1: degToRad(112.5),
                r1: degToRad(67.5),
                r2: degToRad(22.5),
                max: 0,
            };

            const formatted = {
                s2: radar.s2 && radar.s2.value ? radar.s2.value : null,
                s1: radar.s1 && radar.s1.value ? radar.s1.value : null,
                r1: radar.r1 && radar.r1.value ? radar.r1.value : null,
                r2: radar.r2 && radar.r2.value ? radar.r2.value : null,
                price:
                    (radar.price && radar.price.value)
                    || payload.latest_price
                    || (isFiniteNumber(values.price) ? formatPrice(values.price) : null),
            };

            const levelKeys = ['s2', 's1', 'r1', 'r2'];
            const points = levelKeys
                .map((key) => (isFiniteNumber(values[key]) ? { key, value: values[key], angle: anchors[key] } : null))
                .filter(Boolean)
                .sort((a, b) => a.value - b.value);

            if (!points.length && !isFiniteNumber(values.price)) {
                return null;
            }

            const spanHeuristic = (() => {
                if (points.length >= 2) {
                    return Math.max(1, Math.abs(points[points.length - 1].value - points[0].value) * 0.1);
                }
                if (points.length === 1 && isFiniteNumber(values.price)) {
                    return Math.max(1, Math.abs(values.price - points[0].value) * 0.5);
                }
                if (points.length === 1) {
                    return Math.max(1, Math.abs(points[0].value) * 0.1);
                }
                if (isFiniteNumber(values.price)) {
                    return Math.max(1, Math.abs(values.price) * 0.1);
                }
                return 1;
            })();

            const lowerBaseline = points.length ? points[0].value : values.price;
            const upperBaseline = points.length ? points[points.length - 1].value : values.price;
            const fallbackLower = isFiniteNumber(lowerBaseline) ? lowerBaseline - spanHeuristic : -spanHeuristic;
            const fallbackUpper = isFiniteNumber(upperBaseline) ? upperBaseline + spanHeuristic : spanHeuristic;

            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

            const resolveAngleForPrice = (priceValue) => {
                if (!isFiniteNumber(priceValue) || !points.length) {
                    return anchors.s1;
                }
                if (priceValue <= points[0].value) {
                    const ratio = (priceValue - fallbackLower) / (points[0].value - fallbackLower || 1);
                    return anchors.min + (points[0].angle - anchors.min) * clamp(ratio, 0, 1);
                }
                for (let idx = 0; idx < points.length - 1; idx += 1) {
                    const current = points[idx];
                    const next = points[idx + 1];
                    if (priceValue <= next.value) {
                        const ratio = (priceValue - current.value) / (next.value - current.value || 1);
                        return current.angle + (next.angle - current.angle) * clamp(ratio, 0, 1);
                    }
                }
                const last = points[points.length - 1];
                const ratio = (priceValue - last.value) / (fallbackUpper - last.value || 1);
                return last.angle + (anchors.max - last.angle) * clamp(ratio, 0, 1);
            };

            const priceAngle = resolveAngleForPrice(values.price);

            const determineZone = () => {
                const priceVal = values.price;
                const s2Val = values.s2;
                const s1Val = values.s1;
                const r1Val = values.r1;
                const r2Val = values.r2;

                if (!isFiniteNumber(priceVal)) {
                    return 'midZone';
                }
                if (isFiniteNumber(s2Val) && priceVal < s2Val) {
                    return 'belowS2';
                }
                if (isFiniteNumber(s1Val) && priceVal < s1Val) {
                    return 'betweenSupports';
                }
                if (isFiniteNumber(r1Val) && priceVal <= r1Val) {
                    return 'midZone';
                }
                if (isFiniteNumber(r2Val) && priceVal <= r2Val) {
                    return 'betweenResistances';
                }
                if (!isFiniteNumber(r2Val) && isFiniteNumber(r1Val) && priceVal > r1Val) {
                    return 'betweenResistances';
                }
                return 'aboveR2';
            };

            const rangeMinCandidate = isFiniteNumber(values.s2)
                ? values.s2
                : isFiniteNumber(values.s1)
                ? values.s1
                : values.price;
            const rangeMaxCandidate = isFiniteNumber(values.r2)
                ? values.r2
                : isFiniteNumber(values.r1)
                ? values.r1
                : values.price;

            const resolvedMinValue = isFiniteNumber(rangeMinCandidate) ? rangeMinCandidate : fallbackLower;
            const resolvedMaxValue = isFiniteNumber(rangeMaxCandidate) ? rangeMaxCandidate : fallbackUpper;
            const formatOrNull = (num) => (isFiniteNumber(num) ? formatPrice(num) : null);

            return {
                values,
                formatted,
                anchors,
                segments: [
                    { key: 'belowS2', start: anchors.min, end: anchors.s2, color: gaugeColors.belowS2 },
                    { key: 'betweenSupports', start: anchors.s2, end: anchors.s1, color: gaugeColors.betweenSupports },
                    { key: 'midZone', start: anchors.s1, end: anchors.r1, color: gaugeColors.midZone },
                    { key: 'betweenResistances', start: anchors.r1, end: anchors.r2, color: gaugeColors.betweenResistances },
                    { key: 'aboveR2', start: anchors.r2, end: anchors.max, color: gaugeColors.aboveR2 },
                ],
                needleAngle: priceAngle,
                zone: determineZone(),
                range: {
                    minValue: resolvedMinValue,
                    maxValue: resolvedMaxValue,
                    minLabel: formatted.s2 || formatted.s1 || formatted.price || formatOrNull(resolvedMinValue) || 'N/A',
                    maxLabel: formatted.r2 || formatted.r1 || formatted.price || formatOrNull(resolvedMaxValue) || 'N/A',
                },
            };
        }

        function drawGauge(canvas, config) {
            if (!canvas || !config) {
                return;
            }

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                return;
            }

            const ratio = window.devicePixelRatio || 1;
            const width = canvas.clientWidth || canvas.width || 0;
            const height = canvas.clientHeight || canvas.height || 0;
            if (!width || !height) {
                return;
            }

            const displayWidth = Math.round(width * ratio);
            const displayHeight = Math.round(height * ratio);
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(ratio, ratio);

            const centerX = width / 2;
            const centerY = height - 10;
            const baseRadius = Math.min(width / 2 - 20, height - 28);
            const radius = Math.max(48, baseRadius);
            const lineWidth = Math.max(12, radius * 0.22);
            let stripeOuterRadius = Math.min(centerY - 4, radius + lineWidth * 0.48);
            let stripeInnerRadius = Math.max(radius + lineWidth * 0.1, stripeOuterRadius - lineWidth * 0.34);
            if (stripeInnerRadius >= stripeOuterRadius) {
                stripeInnerRadius = Math.max(radius + lineWidth * 0.08, stripeOuterRadius - 6);
            }
            stripeOuterRadius = Math.max(stripeOuterRadius, stripeInnerRadius + 4);
            const effectiveStripeThickness = Math.max(4, stripeOuterRadius - stripeInnerRadius);

            ctx.lineCap = 'round';
            ctx.lineWidth = lineWidth;

            ctx.save();
            if (typeof ctx.createConicGradient === 'function') {
                const stripeGradient = ctx.createConicGradient(Math.PI, centerX, centerY);
                stripeGradient.addColorStop(0, '#581c1c');
                stripeGradient.addColorStop(0.18, '#7f1d1d');
                stripeGradient.addColorStop(0.36, '#b45309');
                stripeGradient.addColorStop(0.5, '#0f766e');
                stripeGradient.addColorStop(0.82, '#0f766e');
                stripeGradient.addColorStop(1, '#064e3b');
                ctx.fillStyle = stripeGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, stripeOuterRadius, Math.PI, 0, true);
                ctx.arc(centerX, centerY, stripeInnerRadius, 0, Math.PI, false);
                ctx.closePath();
                ctx.fill();
            } else {
                const fallbackGradient = ctx.createLinearGradient(centerX - radius, centerY, centerX + radius, centerY);
                fallbackGradient.addColorStop(0, '#581c1c');
                fallbackGradient.addColorStop(0.5, '#b45309');
                fallbackGradient.addColorStop(1, '#064e3b');
                ctx.strokeStyle = fallbackGradient;
                ctx.lineWidth = effectiveStripeThickness;
                ctx.beginPath();
                ctx.arc(centerX, centerY, stripeInnerRadius + effectiveStripeThickness / 2, Math.PI, 0, true);
                ctx.stroke();
            }
            ctx.restore();

            ctx.lineCap = 'round';
            ctx.lineWidth = lineWidth;

            ctx.strokeStyle = 'rgba(15, 23, 42, 0.32)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 0, true);
            ctx.stroke();

            const innerFillRadius = Math.max(0, radius - lineWidth * 0.6);
            const zoneFill = gaugeZoneFill[config.zone] || 'rgba(30, 41, 59, 0.32)';
            ctx.fillStyle = zoneFill;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, innerFillRadius, Math.PI, 0, true);
            ctx.closePath();
            ctx.fill();

            config.segments.forEach((segment) => {
                ctx.strokeStyle = segment.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, segment.start, segment.end, true);
                ctx.stroke();
            });

            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(248, 250, 252, 0.65)';
            const innerRadius = radius - lineWidth / 2 - 6;
            const outerRadius = innerRadius + 10;
            const tickAngles = [
                config.anchors.min,
                config.anchors.s2,
                config.anchors.s1,
                config.anchors.r1,
                config.anchors.r2,
                config.anchors.max,
            ];
            tickAngles.forEach((angle) => {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(centerX + cos * innerRadius, centerY - sin * innerRadius);
                ctx.lineTo(centerX + cos * outerRadius, centerY - sin * outerRadius);
                ctx.stroke();
            });

            const labelFontSize = Math.max(12, Math.min(18, width * 0.08));
            const labelRadius = radius - lineWidth * 0.45;
            const renderLevelLabel = (angle, text, highlight = false) => {
                if (!text) {
                    return;
                }
                ctx.save();
                ctx.font = `600 ${labelFontSize}px 'Inter', 'Segoe UI', Arial`;
                ctx.fillStyle = highlight ? '#fef9c3' : 'rgba(241, 245, 249, 0.86)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const x = centerX + Math.cos(angle) * labelRadius;
                const y = centerY - Math.sin(angle) * labelRadius;
                const strokeColor = highlight ? 'rgba(15, 23, 42, 0.55)' : 'rgba(15, 23, 42, 0.35)';
                ctx.lineWidth = highlight ? 2 : 1.5;
                ctx.strokeStyle = strokeColor;
                ctx.strokeText(text, x, y);
                ctx.fillText(text, x, y);
                ctx.restore();
            };

            renderLevelLabel(config.anchors.s2, config.formatted.s2);
            renderLevelLabel(config.anchors.s1, config.formatted.s1);
            renderLevelLabel(config.anchors.r1, config.formatted.r1);
            renderLevelLabel(config.anchors.r2, config.formatted.r2);

            const needleAngle = typeof config.needleAngle === 'number' ? config.needleAngle : config.anchors.s1;
            const needleLength = radius - lineWidth * 0.68;
            const needleCos = Math.cos(needleAngle);
            const needleSin = Math.sin(needleAngle);
            const needleStartOffset = Math.min(radius * 0.22, lineWidth * 0.85);
            const startXRaw = centerX + needleCos * needleStartOffset;
            const startYRaw = centerY - needleSin * needleStartOffset;
            const endX = centerX + needleCos * needleLength;
            const endY = centerY - needleSin * needleLength;

            ctx.save();
            ctx.shadowColor = 'rgba(253, 230, 138, 0.45)';
            ctx.shadowBlur = 12;
            ctx.strokeStyle = '#fde68a';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(startXRaw, startYRaw);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.restore();

            ctx.fillStyle = '#0f172a';
            ctx.beginPath();
            ctx.arc(centerX, centerY, lineWidth * 0.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fde68a';
            ctx.beginPath();
            ctx.arc(centerX, centerY, lineWidth * 0.24, 0, Math.PI * 2);
            ctx.fill();

            const tipX = centerX + needleCos * (needleLength - 6);
            const tipY = centerY - needleSin * (needleLength - 6);
            ctx.fillStyle = '#fef9c3';
            ctx.beginPath();
            ctx.arc(tipX, tipY, 4, 0, Math.PI * 2);
            ctx.fill();

            const clampLabelCoordinate = (value, min, max) => Math.max(min, Math.min(max, value));
            const labelX = clampLabelCoordinate(startXRaw, width * 0.22, width * 0.78);
            const labelY = clampLabelCoordinate(startYRaw, height * 0.38, height * 0.78);
            const parent = canvas.parentElement;
            if (parent) {
                const labelNode = parent.querySelector('[data-gauge-price]');
                if (labelNode) {
                    const percentX = (labelX / width) * 100;
                    const percentY = (labelY / height) * 100;
                    labelNode.style.setProperty('--needle-label-x', `${percentX.toFixed(2)}%`);
                    labelNode.style.setProperty('--needle-label-y', `${percentY.toFixed(2)}%`);
                }
            }
        }

        function updateGaugeDisplay(payload) {
            if (!gaugeCanvas && !gaugeRange && !gaugePriceValue) {
                return;
            }

            const gaugeContainer = document.querySelector('.level-gauge');
            const gaugeBody = document.querySelector('.level-gauge__body');

            if (!payload) {
                if (gaugeCanvas) {
                    const ctx = gaugeCanvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, gaugeCanvas.width, gaugeCanvas.height);
                    }
                    gaugeCanvas.removeAttribute('data-zone');
                    gaugeCanvas.setAttribute('aria-label', 'Price gauge unavailable');
                }
                if (gaugeRange) {
                    gaugeRange.textContent = 'N/A - N/A';
                }
                if (gaugePriceValue) {
                    gaugePriceValue.textContent = 'N/A';
                    gaugePriceValue.style.opacity = '0';
                }
                if (gaugeContainer) {
                    gaugeContainer.removeAttribute('data-zone');
                }
                if (gaugeBody) {
                    gaugeBody.removeAttribute('data-zone');
                }
                return;
            }

            const config = buildGaugeConfig(payload);

            if (gaugeBody) {
                if (config && config.zone) {
                    gaugeBody.setAttribute('data-zone', config.zone);
                } else {
                    gaugeBody.removeAttribute('data-zone');
                }
            }
            if (gaugeContainer) {
                if (config && config.zone) {
                    gaugeContainer.setAttribute('data-zone', config.zone);
                } else {
                    gaugeContainer.removeAttribute('data-zone');
                }
            }

            if (gaugePriceValue) {
                const priceLabel =
                    (config && config.formatted.price)
                    || (payload.radar && payload.radar.price && payload.radar.price.value)
                    || payload.latest_price
                    || 'N/A';
                gaugePriceValue.textContent = priceLabel || 'N/A';
                gaugePriceValue.style.opacity = config ? '1' : '0';
            }

            if (!config) {
                if (gaugeRange) {
                    gaugeRange.textContent = 'N/A - N/A';
                }
                if (gaugeCanvas) {
                    const ctx = gaugeCanvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, gaugeCanvas.width, gaugeCanvas.height);
                    }
                    gaugeCanvas.setAttribute('aria-label', 'Price gauge unavailable');
                    gaugeCanvas.removeAttribute('data-zone');
                }
                if (gaugePriceValue) {
                    gaugePriceValue.style.opacity = '0';
                }
                return;
            }

            const minLabel = config.range.minLabel || 'N/A';
            const maxLabel = config.range.maxLabel || 'N/A';

            if (gaugeRange) {
                gaugeRange.textContent = `${minLabel} - ${maxLabel}`;
            }

            if (!payload.chart) {
                payload.chart = {};
            }
            payload.chart.min_value = config.range.minValue;
            payload.chart.max_value = config.range.maxValue;
            payload.chart.min = minLabel;
            payload.chart.max = maxLabel;

            if (
                isFiniteNumber(config.values.price)
                && isFiniteNumber(config.range.minValue)
                && isFiniteNumber(config.range.maxValue)
                && config.range.maxValue !== config.range.minValue
            ) {
                const span = config.range.maxValue - config.range.minValue;
                const normalised = Math.max(0, Math.min(1, (config.values.price - config.range.minValue) / span));
                payload.chart.position = normalised;
                if (payload.radar && payload.radar.price) {
                    payload.radar.price.position = normalised;
                }
            } else {
                payload.chart.position = 0.5;
                if (payload.radar && payload.radar.price) {
                    payload.radar.price.position = 0.5;
                }
            }

            if (gaugeCanvas) {
                drawGauge(gaugeCanvas, config);
                if (config.zone) {
                    gaugeCanvas.setAttribute('data-zone', config.zone);
                } else {
                    gaugeCanvas.removeAttribute('data-zone');
                }
                const zoneLabel = gaugeZoneLabels[config.zone] || config.zone;
                const ariaDescription = [
                    payload.symbol ? `Gauge for ${payload.symbol}` : null,
                    config.formatted.s2 ? `lower bound ${config.formatted.s2}` : null,
                    config.formatted.s1 ? `support ${config.formatted.s1}` : null,
                    config.formatted.r1 ? `resistance ${config.formatted.r1}` : null,
                    config.formatted.r2 ? `higher resistance ${config.formatted.r2}` : null,
                    config.formatted.price ? `needle at ${config.formatted.price}` : null,
                    zoneLabel ? `active zone ${zoneLabel}` : null,
                ]
                    .filter(Boolean)
                    .join(', ');
                if (ariaDescription) {
                    gaugeCanvas.setAttribute('aria-label', ariaDescription);
                }
            }
        }

        function applyLivePrice(price, timestamp) {
            if (typeof price !== 'number' || Number.isNaN(price)) {
                return;
            }
            if (!state) {
                state = { symbol: defaultSymbol };
            }
            const formatted = formatPrice(price) || String(price);
            state.latest_price_value = price;
            state.latest_price = formatted;
            if (!state.radar) {
                state.radar = {};
            }
            if (!state.radar.price) {
                state.radar.price = {};
            }
            state.radar.price.value = formatted;
            const priceNode = document.querySelector('.level-marker--price .level-marker__value');
            if (priceNode) {
                priceNode.textContent = formatted;
            }

            updateGaugeDisplay(state);

            if (state.radar && state.radar.price) {
                const root = document.querySelector('.level-radar__track');
                if (root && typeof state.chart.position === 'number') {
                    root.style.setProperty('--price-position', state.chart.position);
                }
            }
        }

        function updateFromPayload(payload) {
            if (!payload) {
                return;
            }
            if (typeof payload.favorite === 'boolean') {
                favoriteState = payload.favorite;
                updateFavoriteButton(favoriteState);
            }
            const meta = document.querySelector('.action-center__meta');
            if (meta) {
                const symbolText = payload.symbol || defaultSymbol;
                const updated = payload.generated_display ? ` &middot; Updated ${payload.generated_display}` : '';
                meta.innerHTML = `Symbol <strong>${symbolText}</strong>${updated}`;
            }
            const primary = payload.primary_action || {};
            const actionCard = document.querySelector('[data-section="primary"]');
            if (actionCard) {
                const statusTitle = actionCard.querySelector('.action-card__status-title');
                const statusSubtitle = actionCard.querySelector('.action-card__status-subtitle');
                if (statusTitle) statusTitle.textContent = primary.title || 'WAIT';
                if (statusSubtitle) statusSubtitle.textContent = primary.subtitle || '';
                actionCard.querySelectorAll('.action-card__details p').forEach((p, index) => {
                    if (primary.explanation && primary.explanation[index]) {
                        p.textContent = primary.explanation[index];
                    }
                });
                const confidenceBar = actionCard.querySelector('.confidence-meter__bar span');
                if (confidenceBar) {
                    const score = primary.confidence_score || 0;
                    confidenceBar.style.width = `${Math.max(0, Math.min(score, 100))}%`;
                    confidenceBar.dataset.width = score;
                }
            }

            ['bias', 'volatility', 'signal'].forEach((key) => {
                const gauge = document.querySelector(`.gauge[data-gauge="${key}"]`);
                if (!gauge || !payload.gauges || !payload.gauges[key]) {
                    return;
                }
                const info = payload.gauges[key];
                gauge.setAttribute('data-live-value', info.score || 0);
                const label = gauge.querySelector('strong');
                if (label) label.textContent = info.label || '';
            });
            applyGaugeStyles();
            applyConfidenceBar();
            updateGaugeDisplay(payload);

            const radar = payload.radar || {};
            const radarRoot = document.querySelector('.level-radar__track');
            if (radarRoot && radar.price && typeof radar.price.position === 'number') {
                radarRoot.style.setProperty('--price-position', radar.price.position);
                const priceValue = radarRoot.querySelector('.level-marker--price .level-marker__value');
                if (priceValue) priceValue.textContent = radar.price.value || 'N/A';
            }
            [['s2', 'level-marker--s2'], ['s1', 'level-marker--s1'], ['r1', 'level-marker--r1'], ['r2', 'level-marker--r2']].forEach(([key, cls]) => {
                const node = document.querySelector(`.${cls}`);
                if (!node || !radar[key]) return;
                const info = radar[key];
                const valueNode = node.querySelector('.level-marker__value');
                const deltaNode = node.querySelector('.level-marker__delta');
                if (valueNode) valueNode.textContent = info.value || 'N/A';
                if (deltaNode) deltaNode.textContent = info.distance || '';
            });

            const traffic = document.querySelector('.traffic-light');
            if (traffic) {
                traffic.classList.remove('traffic-light--buy', 'traffic-light--sell', 'traffic-light--wait');
                traffic.classList.add(`traffic-light--${payload.traffic_light || 'wait'}`);
            }

            const alertsList = document.querySelector('.alerts ul');
            if (alertsList) {
                alertsList.innerHTML = '';
                if (payload.alerts && payload.alerts.length) {
                    payload.alerts.forEach((alertText) => {
                        const li = document.createElement('li');
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.className = 'alert-button';
                        button.textContent = alertText;
                        button.dataset.alert = alertText;
                        li.appendChild(button);
                        alertsList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    li.textContent = 'No alerts suggested.';
                    alertsList.appendChild(li);
                }
            }

            const tagsFooter = document.querySelector('.action-tags');
            if (tagsFooter) {
                tagsFooter.innerHTML = '';
                (payload.tags || []).forEach((tag) => {
                    const span = document.createElement('span');
                    span.textContent = tag;
                    tagsFooter.appendChild(span);
                });
            }

            const scenarioCards = document.querySelectorAll('.scenario-card');
            const scenarios = payload.scenarios || [];
            scenarioCards.forEach((card, index) => {
                const scenario = scenarios[index];
                if (!scenario) return;
                const titleNode = card.querySelector('h3');
                const bodyNode = card.querySelector('p');
                if (titleNode) titleNode.textContent = scenario.title || titleNode.textContent;
                if (bodyNode) bodyNode.textContent = scenario.body || bodyNode.textContent;
                card.classList.remove('scenario-card--bull', 'scenario-card--bear', 'scenario-card--range');
                card.classList.add(`scenario-card--${scenario.icon || 'range'}`);
            });

            const tradePlan = payload.trade_plan || {};
            const entryFields = tradePlan.entry || {};
            document.querySelectorAll('[data-entry-field]').forEach((node) => {
                const field = node.getAttribute('data-entry-field');
                const value = entryFields[field] || 'N/A';
                node.textContent = value;
            });

            const targetsList = document.querySelector('[data-plan-targets]');
            if (targetsList) {
                targetsList.innerHTML = '';
                const targets = tradePlan.targets || [];
                if (targets.length) {
                    targets.slice(0, 3).forEach((target) => {
                        const li = document.createElement('li');
                        const strong = document.createElement('strong');
                        strong.textContent = target;
                        li.appendChild(strong);
                        targetsList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    const strong = document.createElement('strong');
                    strong.textContent = 'N/A';
                    li.appendChild(strong);
                    targetsList.appendChild(li);
                }
            }

            const stopsList = document.querySelector('[data-plan-stops]');
            if (stopsList) {
                stopsList.innerHTML = '';
                const stops = tradePlan.stops || [];
                if (stops.length) {
                    stops.slice(0, 3).forEach((stop) => {
                        const li = document.createElement('li');
                        const strong = document.createElement('strong');
                        strong.textContent = stop;
                        li.appendChild(strong);
                        stopsList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    const strong = document.createElement('strong');
                    strong.textContent = 'N/A';
                    li.appendChild(strong);
                    stopsList.appendChild(li);
                }
            }

            const positionNode = document.querySelector('[data-plan-size]');
            if (positionNode) {
                positionNode.textContent = tradePlan.position_size || 'N/A';
            }

            const riskList = document.querySelector('[data-plan-risk]');
            if (riskList) {
                riskList.innerHTML = '';
                const notes = tradePlan.risk_notes || [];
                if (notes.length) {
                    notes.slice(0, 4).forEach((note) => {
                        const li = document.createElement('li');
                        li.textContent = note;
                        riskList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    li.textContent = 'No additional risk notes.';
                    riskList.appendChild(li);
                }
            }
        }

        async function refreshData() {
            if (!state) return;
            const params = new URLSearchParams({
                symbol: state.symbol || defaultSymbol,
                timeframe: '{{ timeframe }}',
                intent: '{{ intent }}'
            });
            try {
                const response = await fetch(`/api/action-center?${params.toString()}`, { headers: { 'Accept': 'application/json' } });
                if (!response.ok) {
                    console.warn('Action Center refresh skipped', response.status);
                    return;
                }
                const payload = await response.json();
                if (payload && payload.action) {
                    state = payload.action;
                    if (typeof payload.favorite === 'boolean') {
                        favoriteState = payload.favorite;
                        state.favorite = favoriteState;
                        updateFavoriteButton(favoriteState);
                    }
                    updateFromPayload(state);
                }
            } catch (error) {
                console.warn('Failed to refresh Action Center data', error);
            }
        }

        async function refreshLivePrice() {
            if (!livePriceEnabled) return;
            const targetSymbol = (state && state.symbol) || (favoriteButton && favoriteButton.dataset.symbol) || defaultSymbol;
            if (!targetSymbol) return;
            try {
                const response = await fetch(`/api/live-price?symbol=${encodeURIComponent(targetSymbol)}`, { headers: { 'Accept': 'application/json' } });
                if (response.status === 503) {
                    console.warn('Live price stream unavailable');
                    stopLivePrice();
                    return;
                }
                if (response.status === 202) {
                    return;
                }
                if (!response.ok) {
                    console.warn('Live price request failed', response.status);
                    return;
                }
                const payload = await response.json();
                if (payload && typeof payload.price === 'number') {
                    applyLivePrice(payload.price, payload.timestamp);
                }
            } catch (error) {
                console.warn('Failed to refresh live price', error);
            }
        }

        function startAutoRefresh() {
            if (refreshTimer) return;
            refreshTimer = window.setInterval(refreshData, 30000);
        }

        function stopAutoRefresh() {
            if (!refreshTimer) return;
            window.clearInterval(refreshTimer);
            refreshTimer = null;
        }

        function startLivePrice() {
            if (!livePriceEnabled || livePriceTimer) return;
            livePriceTimer = window.setInterval(refreshLivePrice, 7000);
            refreshLivePrice();
        }

        function stopLivePrice() {
            if (!livePriceTimer) return;
            window.clearInterval(livePriceTimer);
            livePriceTimer = null;
        }

        if (autoToggle) {
            autoToggle.addEventListener('change', (event) => {
                if (event.target.checked) {
                    startAutoRefresh();
                    refreshData();
                    startLivePrice();
                } else {
                    stopAutoRefresh();
                    stopLivePrice();
                }
            });
            if (autoToggle.checked) {
                startAutoRefresh();
                startLivePrice();
            }
        }

        if (favoriteButton) {
            favoriteButton.addEventListener('click', async () => {
                const targetSymbol = (state && state.symbol) || favoriteButton.dataset.symbol || defaultSymbol;
                if (!targetSymbol) {
                    return;
                }
                const nextState = !favoriteState;
                favoriteButton.disabled = true;
                try {
                    const response = await fetch('/api/action-center/favorites', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({ symbol: targetSymbol, follow: nextState })
                    });
                    if (!response.ok) {
                        console.warn('Favorite toggle failed', response.status);
                        return;
                    }
                    const result = await response.json();
                    favoriteState = Boolean(result.follow);
                    updateFavoriteButton(favoriteState);
                    if (!state) {
                        state = { symbol: targetSymbol };
                    }
                    state.favorite = favoriteState;
                } catch (error) {
                    console.warn('Failed to update favorite symbol', error);
                } finally {
                    favoriteButton.disabled = false;
                }
            });
        }

        if (gaugeCanvas) {
            window.addEventListener('resize', () => {
                if (gaugeResizeTimer) {
                    window.clearTimeout(gaugeResizeTimer);
                }
                gaugeResizeTimer = window.setTimeout(() => {
                    if (state) {
                        updateGaugeDisplay(state);
                        const radar = state.radar || {};
                        if (radar.price && typeof radar.price.position === 'number') {
                            const radarRoot = document.querySelector('.level-radar__track');
                            if (radarRoot) {
                                radarRoot.style.setProperty('--price-position', radar.price.position);
                            }
                        }
                    }
                }, 150);
            });
        }

        applyGaugeStyles();
        applyConfidenceBar();

        if (state) {
            if (typeof state.favorite === 'boolean') {
                favoriteState = state.favorite;
            }
            updateFavoriteButton(favoriteState);
            updateFromPayload(state);
        } else {
            updateFavoriteButton(favoriteState);
        }

        if (livePriceEnabled) {
            refreshLivePrice();
        }
    }());
    </script>
</body>
</html>
