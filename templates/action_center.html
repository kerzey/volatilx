<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VolatilX - Action Center</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body class="action-center-page" data-live-price="{{ 'true' if live_price_enabled else 'false' }}">
    <div class="header">
        <a class="logo" href="/analyze">
            <img src="/static/VolatilX_Logo.PNG" alt="VolatilX Logo">
            <span>VolatilX</span>
        </a>
        <div class="nav-links">
            <a href="/analyze">AI Insights</a>
            <a href="/action-center" class="active">Action Center</a>
            <a href="/report-center">Report Center</a>
            <a href="/subscribe">Plans</a>
            <a href="/settings">Settings</a>
            <span>{{ user.email }}</span>
            <a href="/logout">Logout</a>
        </div>
    </div>

    <main class="action-center">
        <header class="action-center__header">
            <div>
                <h1>Action Center</h1>
                <p>Your AI-powered trading cockpit &mdash; real-time signals, levels, and actions.</p>
                {% if action_data %}
                <p class="action-center__meta">Symbol <strong>{{ action_data.symbol }}</strong>{% if action_data.generated_display %} &middot; Updated {{ action_data.generated_display }}{% endif %}</p>
                {% endif %}
            </div>
            <form class="action-controls" method="get" action="/action-center">
                <input type="hidden" name="symbol" value="{{ symbol }}">
                <label class="control-group">
                    <span>Timeframe</span>
                    <select name="timeframe" aria-label="Select timeframe">
                        <option value="day"{% if timeframe == 'day' %} selected{% endif %}>Day</option>
                        <option value="swing"{% if timeframe == 'swing' %} selected{% endif %}>Swing</option>
                        <option value="long"{% if timeframe == 'long' %} selected{% endif %}>Long</option>
                    </select>
                </label>
                <label class="control-group">
                    <span>Intent</span>
                    <select name="intent" aria-label="Select intent">
                        <option value="buy"{% if intent == 'buy' %} selected{% endif %}>Buy</option>
                        <option value="sell"{% if intent == 'sell' %} selected{% endif %}>Sell</option>
                    </select>
                </label>
                <button type="submit" class="pill-button">Update View</button>
                <button
                    type="button"
                    class="pill-button pill-button--ghost{% if is_favorited %} pill-button--active{% endif %}"
                    id="favoriteSymbol"
                    data-symbol="{{ symbol }}"
                    aria-pressed="{{ 'true' if is_favorited else 'false' }}"
                >
                    {{ 'Following' if is_favorited else 'Follow Symbol' }}
                </button>
                <label class="toggle" for="autoRefreshToggle">
                    <input type="checkbox" id="autoRefreshToggle" name="autoupdate" value="1">
                    <span>Auto-update</span>
                </label>
            </form>
        </header>

        {% if error_message %}
        <div class="action-center__empty">
            <p>{{ error_message }}</p>
        </div>
        {% endif %}

        {% if action_data %}
        <section class="action-card" data-section="primary">
            <div class="action-card__label">What should I do?</div>
            <div class="action-card__body">
                <div class="action-card__status action-card__status--{{ action_data.primary_action.icon }}">
                    <span class="action-card__status-title">{{ action_data.primary_action.title }}</span>
                    <span class="action-card__status-subtitle">{{ action_data.primary_action.subtitle }}</span>
                </div>
                <div class="action-card__details">
                    {% for line in action_data.primary_action.explanation %}
                    <p>{{ line }}</p>
                    {% endfor %}
                </div>
                <div class="confidence-meter" data-confidence="{{ action_data.primary_action.confidence_score }}">
                    <div class="confidence-meter__label">Confidence {{ action_data.primary_action.confidence }}</div>
                    <div class="confidence-meter__bar"><span data-confidence-bar data-width="{{ action_data.primary_action.confidence_score }}"></span></div>
                </div>
            </div>
        </section>

        <section class="gauge-cluster">
            <div class="gauge" data-gauge="bias" style="--gauge-value: {{ action_data.gauges.bias.score }}">
                <div class="gauge__dial"></div>
                <div class="gauge__content">
                    <span class="gauge__label">Bias</span>
                    <strong>{{ action_data.gauges.bias.label }}</strong>
                </div>
            </div>
            <div class="gauge" data-gauge="volatility" style="--gauge-value: {{ action_data.gauges.volatility.score }}">
                <div class="gauge__dial"></div>
                <div class="gauge__content">
                    <span class="gauge__label">Volatility</span>
                    <strong>{{ action_data.gauges.volatility.label }}</strong>
                </div>
            </div>
            <div class="gauge" data-gauge="signal" style="--gauge-value: {{ action_data.gauges.signal.score }}">
                <div class="gauge__dial"></div>
                <div class="gauge__content">
                    <span class="gauge__label">Signal Strength</span>
                    <strong>{{ action_data.gauges.signal.label }}</strong>
                </div>
            </div>
        </section>

        <section class="level-radar" aria-label="Support and resistance radar">
            <div class="level-radar__track" style="--price-position: {{ action_data.radar.price.position or 0.5 }}">
                <div class="level-marker level-marker--s2">
                    <span class="level-marker__title">Support-2</span>
                    <span class="level-marker__value">{{ action_data.radar.s2.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.s2.distance or '' }}</span>
                </div>
                <div class="level-marker level-marker--s1">
                    <span class="level-marker__title">Support-1</span>
                    <span class="level-marker__value">{{ action_data.radar.s1.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.s1.distance or '' }}</span>
                </div>
                <div class="level-marker level-marker--price">
                    <span class="level-marker__title">Price</span>
                    <span class="level-marker__value">{{ action_data.radar.price.value or 'N/A' }}</span>
                </div>
                <div class="level-marker level-marker--r1">
                    <span class="level-marker__title">Resistance-1</span>
                    <span class="level-marker__value">{{ action_data.radar.r1.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.r1.distance or '' }}</span>
                </div>
                <div class="level-marker level-marker--r2">
                    <span class="level-marker__title">Resistance-2</span>
                    <span class="level-marker__value">{{ action_data.radar.r2.value or 'N/A' }}</span>
                    <span class="level-marker__delta">{{ action_data.radar.r2.distance or '' }}</span>
                </div>
            </div>
            <div class="traffic-light traffic-light--{{ action_data.traffic_light }}" aria-label="Market zone indicator"></div>
        </section>

        <section class="scenario-cards">
            {% for scenario in action_data.scenarios %}
            <article class="scenario-card scenario-card--{{ scenario.icon }}">
                <h3>{{ scenario.title }}</h3>
                <p>{{ scenario.body }}</p>
            </article>
            {% endfor %}
        </section>

        <section class="trade-plan">
            <header>
                <h2>Auto-generated trade plan</h2>
                {% if strategy_summary %}
                <p>{{ strategy_summary }}</p>
                {% endif %}
            </header>
            <div class="trade-plan__grid">
                <div>
                    <h3>Entries</h3>
                    <ul>
                        <li><span>Initial</span><strong data-entry-field="primary">{{ action_data.trade_plan.entry.primary or 'N/A' }}</strong></li>
                        <li><span>Scale</span><strong data-entry-field="scale">{{ action_data.trade_plan.entry.scale or 'N/A' }}</strong></li>
                        <li><span>Breakout</span><strong data-entry-field="breakout">{{ action_data.trade_plan.entry.breakout or 'N/A' }}</strong></li>
                    </ul>
                </div>
                <div>
                    <h3>Targets</h3>
                    <ul data-plan-targets>
                        {% for target in action_data.trade_plan.targets %}
                        <li><strong>{{ target }}</strong></li>
                        {% endfor %}
                        {% if not action_data.trade_plan.targets %}
                        <li><strong>N/A</strong></li>
                        {% endif %}
                    </ul>
                </div>
                <div>
                    <h3>Stops</h3>
                    <ul data-plan-stops>
                        {% for stop in action_data.trade_plan.stops %}
                        <li><strong>{{ stop }}</strong></li>
                        {% endfor %}
                        {% if not action_data.trade_plan.stops %}
                        <li><strong>N/A</strong></li>
                        {% endif %}
                    </ul>
                </div>
                <div>
                    <h3>Position Size</h3>
                    <p class="trade-plan__size" data-plan-size>{{ action_data.trade_plan.position_size }}</p>
                    <h3>Risk Notes</h3>
                    <ul data-plan-risk>
                        {% for note in action_data.trade_plan.risk_notes %}
                        <li>{{ note }}</li>
                        {% endfor %}
                        {% if not action_data.trade_plan.risk_notes %}
                        <li>No additional risk notes.</li>
                        {% endif %}
                    </ul>
                </div>
            </div>
        </section>

        <section class="action-lower">
            <div class="alerts">
                <h2>Suggested alerts</h2>
                <ul>
                    {% for alert in action_data.alerts %}
                    <li><button type="button" class="alert-button" data-alert="{{ alert }}">{{ alert }}</button></li>
                    {% endfor %}
                    {% if not action_data.alerts %}
                    <li>No alerts suggested.</li>
                    {% endif %}
                </ul>
            </div>
            <div class="level-gauge" aria-label="Support and resistance luxury gauge">
                <div class="level-gauge__header">
                    <h2>Price range gauge</h2>
                    <span class="level-gauge__range" data-gauge-range>
                        {% set gauge_min = action_data.radar.s2.value if action_data.radar.s2.value else action_data.radar.s1.value %}
                        {% set gauge_max = action_data.radar.r2.value if action_data.radar.r2.value else action_data.radar.r1.value %}
                        {{ gauge_min or 'N/A' }} &ndash; {{ gauge_max or 'N/A' }}
                    </span>
                </div>
                <div class="level-gauge__body">
                    <canvas
                        class="level-gauge__canvas"
                        width="320"
                        height="160"
                        data-gauge-canvas
                        role="img"
                        aria-label="Price gauge"
                    ></canvas>
                    <div class="level-gauge__needle-value" data-gauge-price>{{ action_data.radar.price.value or action_data.latest_price or 'N/A' }}</div>
                </div>
                <div class="level-gauge__markers" aria-hidden="true">
                    <span data-gauge-marker="s2">{{ action_data.radar.s2.value or 'N/A' }}</span>
                    <span data-gauge-marker="s1">{{ action_data.radar.s1.value or 'N/A' }}</span>
                    <span data-gauge-marker="price">{{ action_data.radar.price.value or action_data.latest_price or 'N/A' }}</span>
                    <span data-gauge-marker="r1">{{ action_data.radar.r1.value or 'N/A' }}</span>
                    <span data-gauge-marker="r2">{{ action_data.radar.r2.value or 'N/A' }}</span>
                </div>
            </div>
        </section>

        <footer class="action-tags">
            {% for tag in action_data.tags %}
            <span>{{ tag }}</span>
            {% endfor %}
        </footer>
        {% endif %}
    </main>

    {% if action_data_json %}
    <script id="actionCenterData" type="application/json">{{ action_data_json | safe }}</script>
    {% endif %}
    <script>
    (function() {
        const dataElement = document.getElementById('actionCenterData');
        let state = null;
        if (dataElement) {
            try {
                state = JSON.parse(dataElement.textContent || '{}');
            } catch (error) {
                console.warn('Failed to parse Action Center data payload', error);
            }
        }

        const autoToggle = document.getElementById('autoRefreshToggle');
        const favoriteButton = document.getElementById('favoriteSymbol');
        const defaultSymbol = '{{ symbol }}';
        const livePriceEnabled = document.body.getAttribute('data-live-price') === 'true';
        let refreshTimer = null;
        let livePriceTimer = null;
        let favoriteState = favoriteButton ? favoriteButton.getAttribute('aria-pressed') === 'true' : false;
        const gaugeCanvas = document.querySelector('[data-gauge-canvas]');
        const gaugeRange = document.querySelector('[data-gauge-range]');
        const gaugeMarkers = {
            s2: document.querySelector('[data-gauge-marker="s2"]'),
            s1: document.querySelector('[data-gauge-marker="s1"]'),
            price: document.querySelector('[data-gauge-marker="price"]'),
            r1: document.querySelector('[data-gauge-marker="r1"]'),
            r2: document.querySelector('[data-gauge-marker="r2"]'),
        };
        const gaugePriceValue = document.querySelector('[data-gauge-price]');
        const gaugeColors = {
            belowS2: '#111827',
            betweenSupports: '#0f766e',
            midZone: '#2563eb',
            betweenResistances: '#f59e0b',
            aboveR2: '#dc2626',
        };
        let gaugeResizeTimer = null;

        function updateFavoriteButton(isActive) {
            if (!favoriteButton) return;
            favoriteButton.setAttribute('aria-pressed', String(isActive));
            favoriteButton.classList.toggle('pill-button--active', isActive);
            favoriteButton.textContent = isActive ? 'Following' : 'Follow Symbol';
        }

        function applyGaugeStyles() {
            document.querySelectorAll('.gauge').forEach((gauge) => {
                const value = gauge.getAttribute('data-live-value') || gauge.style.getPropertyValue('--gauge-value');
                if (value) {
                    gauge.style.setProperty('--gauge-value', value);
                }
            });
        }

        function applyConfidenceBar() {
            document.querySelectorAll('[data-confidence-bar]').forEach((node) => {
                const width = Number(node.dataset.width || 0);
                const clamped = Math.max(0, Math.min(width, 100));
                node.style.width = `${clamped}%`;
            });
        }

        function formatPrice(value) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return null;
            }
            return value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function parseNumeric(value) {
            if (typeof value === 'number') {
                return Number.isFinite(value) ? value : null;
            }
            if (typeof value === 'string') {
                const cleaned = value.replace(/,/g, '').trim();
                if (!cleaned) {
                    return null;
                }
                const parsed = Number(cleaned);
                return Number.isFinite(parsed) ? parsed : null;
            }
            return null;
        }

        function buildGaugeConfig(payload) {
            if (!payload) {
                return null;
            }
            const radar = payload.radar || {};
            const values = {
                s2: parseNumeric(radar.s2 && radar.s2.value),
                s1: parseNumeric(radar.s1 && radar.s1.value),
                r1: parseNumeric(radar.r1 && radar.r1.value),
                r2: parseNumeric(radar.r2 && radar.r2.value),
                price:
                    typeof payload.latest_price_value === 'number' && !Number.isNaN(payload.latest_price_value)
                        ? payload.latest_price_value
                        : parseNumeric(radar.price && radar.price.value),
            };

            const numericValues = Object.values(values).filter((val) => typeof val === 'number' && Number.isFinite(val));
            if (!numericValues.length) {
                return null;
            }

            const minCandidate = Math.min(...numericValues);
            const maxCandidate = Math.max(...numericValues);

            const spanCandidates = [];
            if (typeof values.s1 === 'number' && typeof values.s2 === 'number') {
                spanCandidates.push(Math.abs(values.s1 - values.s2));
            }
            if (typeof values.r2 === 'number' && typeof values.r1 === 'number') {
                spanCandidates.push(Math.abs(values.r2 - values.r1));
            }
            if (typeof values.r1 === 'number' && typeof values.s1 === 'number') {
                spanCandidates.push(Math.abs(values.r1 - values.s1));
            }

            const primarySpan = Math.max(
                maxCandidate - minCandidate,
                spanCandidates.length ? Math.max(...spanCandidates) : 0,
                Math.abs(numericValues[0]) || 1
            );
            const extension = primarySpan * 0.15 || 1;

            let minBound = minCandidate;
            let maxBound = maxCandidate;

            if (typeof values.s2 === 'number') {
                minBound = Math.min(values.s2 - extension, minBound);
            } else {
                minBound -= extension;
            }

            if (typeof values.r2 === 'number') {
                maxBound = Math.max(values.r2 + extension, maxBound);
            } else {
                maxBound += extension;
            }

            if (!(maxBound > minBound)) {
                maxBound = minBound + (primarySpan || 1);
            }

            return {
                values,
                minBound,
                maxBound,
                formatted: {
                    s2: radar.s2 && radar.s2.value ? radar.s2.value : null,
                    s1: radar.s1 && radar.s1.value ? radar.s1.value : null,
                    r1: radar.r1 && radar.r1.value ? radar.r1.value : null,
                    r2: radar.r2 && radar.r2.value ? radar.r2.value : null,
                    price: (radar.price && radar.price.value) || payload.latest_price || null,
                },
            };
        }

        function drawGauge(canvas, config) {
            if (!canvas || !config) {
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                return;
            }

            const width = canvas.clientWidth || canvas.width;
            const height = canvas.clientHeight || canvas.height;
            if (!width || !height) {
                return;
            }

            const ratio = window.devicePixelRatio || 1;
            const displayWidth = Math.round(width * ratio);
            const displayHeight = Math.round(height * ratio);
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(ratio, ratio);
            ctx.clearRect(0, 0, width, height);

            const centerX = width / 2;
            const centerY = height;
            const radius = Math.min(width, height * 2) / 2 - 12;
            const lineWidth = 18;
            const span = config.maxBound - config.minBound || 1;
            const epsilon = span * 0.0005;

            const valueToAngle = (value) => {
                const clamped = Math.max(config.minBound, Math.min(config.maxBound, value));
                const normalised = (clamped - config.minBound) / span;
                return Math.PI - normalised * Math.PI;
            };

            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.strokeStyle = 'rgba(15, 23, 42, 0.35)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 0, false);
            ctx.stroke();

            const segments = [];
            let cursor = config.minBound;

            const addSegment = (boundary, color) => {
                if (typeof boundary !== 'number' || !Number.isFinite(boundary)) {
                    return;
                }
                const endValue = Math.max(boundary, cursor + epsilon);
                if (endValue <= cursor) {
                    return;
                }
                segments.push({
                    start: cursor,
                    end: Math.min(endValue, config.maxBound),
                    color,
                });
                cursor = Math.min(endValue, config.maxBound);
            };

            addSegment(config.values.s2, gaugeColors.belowS2);
            addSegment(config.values.s1, gaugeColors.betweenSupports);
            addSegment(config.values.r1, gaugeColors.midZone);
            addSegment(config.values.r2, gaugeColors.betweenResistances);

            if (cursor < config.maxBound) {
                segments.push({
                    start: cursor,
                    end: config.maxBound,
                    color: gaugeColors.aboveR2,
                });
            }

            segments.forEach((segment) => {
                if (!(segment.end > segment.start)) {
                    return;
                }
                ctx.strokeStyle = segment.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, valueToAngle(segment.start), valueToAngle(segment.end), false);
                ctx.stroke();
            });

            const tickCount = 5;
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(248, 250, 252, 0.65)';
            const innerRadius = radius - lineWidth / 2 - 4;
            const outerRadius = innerRadius + 8;
            for (let i = 0; i <= tickCount; i += 1) {
                const fraction = i / tickCount;
                const angle = Math.PI - fraction * Math.PI;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(centerX + cos * innerRadius, centerY + sin * innerRadius);
                ctx.lineTo(centerX + cos * outerRadius, centerY + sin * outerRadius);
                ctx.stroke();
            }

            const needleValue = config.values.price;
            if (typeof needleValue === 'number' && Number.isFinite(needleValue)) {
                const angle = valueToAngle(needleValue);
                const needleLength = radius - lineWidth / 2;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);

                ctx.strokeStyle = '#fef3c7';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + cos * needleLength, centerY + sin * needleLength);
                ctx.stroke();

                ctx.fillStyle = '#0f172a';
                ctx.beginPath();
                ctx.arc(centerX, centerY, lineWidth * 0.45, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fde68a';
                ctx.beginPath();
                ctx.arc(centerX, centerY, lineWidth * 0.24, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateGaugeDisplay(payload) {
            if (!gaugeCanvas && !gaugeRange && !gaugePriceValue) {
                return;
            }

            if (!payload) {
                if (gaugeCanvas) {
                    const ctx = gaugeCanvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, gaugeCanvas.width, gaugeCanvas.height);
                    }
                }
                if (gaugeRange) {
                    gaugeRange.textContent = 'N/A - N/A';
                }
                if (gaugePriceValue) {
                    gaugePriceValue.textContent = 'N/A';
                }
                Object.values(gaugeMarkers).forEach((node) => {
                    if (node) {
                        node.textContent = 'N/A';
                    }
                });
                return;
            }

            const config = buildGaugeConfig(payload);

            if (gaugePriceValue) {
                const priceLabel = (payload.radar && payload.radar.price && payload.radar.price.value) || payload.latest_price || 'N/A';
                gaugePriceValue.textContent = priceLabel || 'N/A';
            }

            Object.entries(gaugeMarkers).forEach(([key, node]) => {
                if (!node) {
                    return;
                }
                const level = payload.radar && payload.radar[key];
                node.textContent = (level && level.value) || 'N/A';
            });

            if (!config) {
                if (gaugeRange) {
                    gaugeRange.textContent = 'N/A - N/A';
                }
                if (gaugeCanvas) {
                    const ctx = gaugeCanvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, gaugeCanvas.width, gaugeCanvas.height);
                    }
                    gaugeCanvas.setAttribute('aria-label', 'Price gauge unavailable');
                }
                return;
            }

            const minLabel = formatPrice(config.minBound) || config.formatted.s2 || config.formatted.s1 || 'N/A';
            const maxLabel = formatPrice(config.maxBound) || config.formatted.r2 || config.formatted.r1 || 'N/A';

            if (gaugeRange) {
                gaugeRange.textContent = `${minLabel} - ${maxLabel}`;
            }

            if (!payload.chart) {
                payload.chart = {};
            }
            payload.chart.min_value = config.minBound;
            payload.chart.max_value = config.maxBound;
            payload.chart.min = minLabel;
            payload.chart.max = maxLabel;

            const span = config.maxBound - config.minBound || 1;
            if (typeof config.values.price === 'number' && Number.isFinite(config.values.price)) {
                const normalised = Math.max(0, Math.min(1, (config.values.price - config.minBound) / span));
                payload.chart.position = normalised;
                if (payload.radar && payload.radar.price) {
                    payload.radar.price.position = normalised;
                }
            }

            if (gaugeCanvas) {
                drawGauge(gaugeCanvas, config);
                const ariaDescription = [
                    payload.symbol ? `Gauge for ${payload.symbol}` : null,
                    config.formatted.s2 ? `lower bound ${config.formatted.s2}` : null,
                    config.formatted.s1 ? `support ${config.formatted.s1}` : null,
                    config.formatted.r1 ? `resistance ${config.formatted.r1}` : null,
                    config.formatted.r2 ? `higher resistance ${config.formatted.r2}` : null,
                    config.formatted.price ? `needle at ${config.formatted.price}` : null,
                ]
                    .filter(Boolean)
                    .join(', ');
                if (ariaDescription) {
                    gaugeCanvas.setAttribute('aria-label', ariaDescription);
                }
            }
        }

        function applyLivePrice(price, timestamp) {
            if (typeof price !== 'number' || Number.isNaN(price)) {
                return;
            }
            if (!state) {
                state = { symbol: defaultSymbol };
            }
            const formatted = formatPrice(price) || String(price);
            state.latest_price_value = price;
            state.latest_price = formatted;
            if (!state.radar) {
                state.radar = {};
            }
            if (!state.radar.price) {
                state.radar.price = {};
            }
            state.radar.price.value = formatted;
            const priceNode = document.querySelector('.level-marker--price .level-marker__value');
            if (priceNode) {
                priceNode.textContent = formatted;
            }

            updateGaugeDisplay(state);

            if (state.radar && state.radar.price) {
                const root = document.querySelector('.level-radar__track');
                if (root && typeof state.chart.position === 'number') {
                    root.style.setProperty('--price-position', state.chart.position);
                }
            }
        }

        function updateFromPayload(payload) {
            if (!payload) {
                return;
            }
            if (typeof payload.favorite === 'boolean') {
                favoriteState = payload.favorite;
                updateFavoriteButton(favoriteState);
            }
            const meta = document.querySelector('.action-center__meta');
            if (meta) {
                const symbolText = payload.symbol || defaultSymbol;
                const updated = payload.generated_display ? ` &middot; Updated ${payload.generated_display}` : '';
                meta.innerHTML = `Symbol <strong>${symbolText}</strong>${updated}`;
            }
            const primary = payload.primary_action || {};
            const actionCard = document.querySelector('[data-section="primary"]');
            if (actionCard) {
                const statusTitle = actionCard.querySelector('.action-card__status-title');
                const statusSubtitle = actionCard.querySelector('.action-card__status-subtitle');
                if (statusTitle) statusTitle.textContent = primary.title || 'WAIT';
                if (statusSubtitle) statusSubtitle.textContent = primary.subtitle || '';
                actionCard.querySelectorAll('.action-card__details p').forEach((p, index) => {
                    if (primary.explanation && primary.explanation[index]) {
                        p.textContent = primary.explanation[index];
                    }
                });
                const confidenceBar = actionCard.querySelector('.confidence-meter__bar span');
                if (confidenceBar) {
                    const score = primary.confidence_score || 0;
                    confidenceBar.style.width = `${Math.max(0, Math.min(score, 100))}%`;
                    confidenceBar.dataset.width = score;
                }
            }

            ['bias', 'volatility', 'signal'].forEach((key) => {
                const gauge = document.querySelector(`.gauge[data-gauge="${key}"]`);
                if (!gauge || !payload.gauges || !payload.gauges[key]) {
                    return;
                }
                const info = payload.gauges[key];
                gauge.setAttribute('data-live-value', info.score || 0);
                const label = gauge.querySelector('strong');
                if (label) label.textContent = info.label || '';
            });
            applyGaugeStyles();
            applyConfidenceBar();
            updateGaugeDisplay(payload);

            const radar = payload.radar || {};
            const radarRoot = document.querySelector('.level-radar__track');
            if (radarRoot && radar.price && typeof radar.price.position === 'number') {
                radarRoot.style.setProperty('--price-position', radar.price.position);
                const priceValue = radarRoot.querySelector('.level-marker--price .level-marker__value');
                if (priceValue) priceValue.textContent = radar.price.value || 'N/A';
            }
            [['s2', 'level-marker--s2'], ['s1', 'level-marker--s1'], ['r1', 'level-marker--r1'], ['r2', 'level-marker--r2']].forEach(([key, cls]) => {
                const node = document.querySelector(`.${cls}`);
                if (!node || !radar[key]) return;
                const info = radar[key];
                const valueNode = node.querySelector('.level-marker__value');
                const deltaNode = node.querySelector('.level-marker__delta');
                if (valueNode) valueNode.textContent = info.value || 'N/A';
                if (deltaNode) deltaNode.textContent = info.distance || '';
            });

            const traffic = document.querySelector('.traffic-light');
            if (traffic) {
                traffic.classList.remove('traffic-light--buy', 'traffic-light--sell', 'traffic-light--wait');
                traffic.classList.add(`traffic-light--${payload.traffic_light || 'wait'}`);
            }

            const alertsList = document.querySelector('.alerts ul');
            if (alertsList) {
                alertsList.innerHTML = '';
                if (payload.alerts && payload.alerts.length) {
                    payload.alerts.forEach((alertText) => {
                        const li = document.createElement('li');
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.className = 'alert-button';
                        button.textContent = alertText;
                        button.dataset.alert = alertText;
                        li.appendChild(button);
                        alertsList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    li.textContent = 'No alerts suggested.';
                    alertsList.appendChild(li);
                }
            }

            const tagsFooter = document.querySelector('.action-tags');
            if (tagsFooter) {
                tagsFooter.innerHTML = '';
                (payload.tags || []).forEach((tag) => {
                    const span = document.createElement('span');
                    span.textContent = tag;
                    tagsFooter.appendChild(span);
                });
            }

            const scenarioCards = document.querySelectorAll('.scenario-card');
            const scenarios = payload.scenarios || [];
            scenarioCards.forEach((card, index) => {
                const scenario = scenarios[index];
                if (!scenario) return;
                const titleNode = card.querySelector('h3');
                const bodyNode = card.querySelector('p');
                if (titleNode) titleNode.textContent = scenario.title || titleNode.textContent;
                if (bodyNode) bodyNode.textContent = scenario.body || bodyNode.textContent;
                card.classList.remove('scenario-card--bull', 'scenario-card--bear', 'scenario-card--range');
                card.classList.add(`scenario-card--${scenario.icon || 'range'}`);
            });

            const tradePlan = payload.trade_plan || {};
            const entryFields = tradePlan.entry || {};
            document.querySelectorAll('[data-entry-field]').forEach((node) => {
                const field = node.getAttribute('data-entry-field');
                const value = entryFields[field] || 'N/A';
                node.textContent = value;
            });

            const targetsList = document.querySelector('[data-plan-targets]');
            if (targetsList) {
                targetsList.innerHTML = '';
                const targets = tradePlan.targets || [];
                if (targets.length) {
                    targets.slice(0, 3).forEach((target) => {
                        const li = document.createElement('li');
                        const strong = document.createElement('strong');
                        strong.textContent = target;
                        li.appendChild(strong);
                        targetsList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    const strong = document.createElement('strong');
                    strong.textContent = 'N/A';
                    li.appendChild(strong);
                    targetsList.appendChild(li);
                }
            }

            const stopsList = document.querySelector('[data-plan-stops]');
            if (stopsList) {
                stopsList.innerHTML = '';
                const stops = tradePlan.stops || [];
                if (stops.length) {
                    stops.slice(0, 3).forEach((stop) => {
                        const li = document.createElement('li');
                        const strong = document.createElement('strong');
                        strong.textContent = stop;
                        li.appendChild(strong);
                        stopsList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    const strong = document.createElement('strong');
                    strong.textContent = 'N/A';
                    li.appendChild(strong);
                    stopsList.appendChild(li);
                }
            }

            const positionNode = document.querySelector('[data-plan-size]');
            if (positionNode) {
                positionNode.textContent = tradePlan.position_size || 'N/A';
            }

            const riskList = document.querySelector('[data-plan-risk]');
            if (riskList) {
                riskList.innerHTML = '';
                const notes = tradePlan.risk_notes || [];
                if (notes.length) {
                    notes.slice(0, 4).forEach((note) => {
                        const li = document.createElement('li');
                        li.textContent = note;
                        riskList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    li.textContent = 'No additional risk notes.';
                    riskList.appendChild(li);
                }
            }
        }

        async function refreshData() {
            if (!state) return;
            const params = new URLSearchParams({
                symbol: state.symbol || defaultSymbol,
                timeframe: '{{ timeframe }}',
                intent: '{{ intent }}'
            });
            try {
                const response = await fetch(`/api/action-center?${params.toString()}`, { headers: { 'Accept': 'application/json' } });
                if (!response.ok) {
                    console.warn('Action Center refresh skipped', response.status);
                    return;
                }
                const payload = await response.json();
                if (payload && payload.action) {
                    state = payload.action;
                    if (typeof payload.favorite === 'boolean') {
                        favoriteState = payload.favorite;
                        state.favorite = favoriteState;
                        updateFavoriteButton(favoriteState);
                    }
                    updateFromPayload(state);
                }
            } catch (error) {
                console.warn('Failed to refresh Action Center data', error);
            }
        }

        async function refreshLivePrice() {
            if (!livePriceEnabled) return;
            const targetSymbol = (state && state.symbol) || (favoriteButton && favoriteButton.dataset.symbol) || defaultSymbol;
            if (!targetSymbol) return;
            try {
                const response = await fetch(`/api/live-price?symbol=${encodeURIComponent(targetSymbol)}`, { headers: { 'Accept': 'application/json' } });
                if (response.status === 503) {
                    console.warn('Live price stream unavailable');
                    stopLivePrice();
                    return;
                }
                if (response.status === 202) {
                    return;
                }
                if (!response.ok) {
                    console.warn('Live price request failed', response.status);
                    return;
                }
                const payload = await response.json();
                if (payload && typeof payload.price === 'number') {
                    applyLivePrice(payload.price, payload.timestamp);
                }
            } catch (error) {
                console.warn('Failed to refresh live price', error);
            }
        }

        function startAutoRefresh() {
            if (refreshTimer) return;
            refreshTimer = window.setInterval(refreshData, 30000);
        }

        function stopAutoRefresh() {
            if (!refreshTimer) return;
            window.clearInterval(refreshTimer);
            refreshTimer = null;
        }

        function startLivePrice() {
            if (!livePriceEnabled || livePriceTimer) return;
            livePriceTimer = window.setInterval(refreshLivePrice, 7000);
            refreshLivePrice();
        }

        function stopLivePrice() {
            if (!livePriceTimer) return;
            window.clearInterval(livePriceTimer);
            livePriceTimer = null;
        }

        if (autoToggle) {
            autoToggle.addEventListener('change', (event) => {
                if (event.target.checked) {
                    startAutoRefresh();
                    refreshData();
                    startLivePrice();
                } else {
                    stopAutoRefresh();
                    stopLivePrice();
                }
            });
            if (autoToggle.checked) {
                startAutoRefresh();
                startLivePrice();
            }
        }

        if (favoriteButton) {
            favoriteButton.addEventListener('click', async () => {
                const targetSymbol = (state && state.symbol) || favoriteButton.dataset.symbol || defaultSymbol;
                if (!targetSymbol) {
                    return;
                }
                const nextState = !favoriteState;
                favoriteButton.disabled = true;
                try {
                    const response = await fetch('/api/action-center/favorites', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({ symbol: targetSymbol, follow: nextState })
                    });
                    if (!response.ok) {
                        console.warn('Favorite toggle failed', response.status);
                        return;
                    }
                    const result = await response.json();
                    favoriteState = Boolean(result.follow);
                    updateFavoriteButton(favoriteState);
                    if (!state) {
                        state = { symbol: targetSymbol };
                    }
                    state.favorite = favoriteState;
                } catch (error) {
                    console.warn('Failed to update favorite symbol', error);
                } finally {
                    favoriteButton.disabled = false;
                }
            });
        }

        if (gaugeCanvas) {
            window.addEventListener('resize', () => {
                if (gaugeResizeTimer) {
                    window.clearTimeout(gaugeResizeTimer);
                }
                gaugeResizeTimer = window.setTimeout(() => {
                    if (state) {
                        updateGaugeDisplay(state);
                        const radar = state.radar || {};
                        if (radar.price && typeof radar.price.position === 'number') {
                            const radarRoot = document.querySelector('.level-radar__track');
                            if (radarRoot) {
                                radarRoot.style.setProperty('--price-position', radar.price.position);
                            }
                        }
                    }
                }, 150);
            });
        }

        applyGaugeStyles();
        applyConfidenceBar();

        if (state) {
            if (typeof state.favorite === 'boolean') {
                favoriteState = state.favorite;
            }
            updateFavoriteButton(favoriteState);
            updateFromPayload(state);
        } else {
            updateFavoriteButton(favoriteState);
        }

        if (livePriceEnabled) {
            refreshLivePrice();
        }
    }());
    </script>
</body>
</html>
