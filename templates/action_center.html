<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VolatilX - Action Center</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body class="action-center-page" data-live-price="{{ 'true' if live_price_enabled else 'false' }}" data-timeframe="{{ timeframe }}" data-intent="{{ intent }}">
    <div class="header">
        <a class="logo" href="/analyze">
            <img src="/static/VolatilX_Logo.PNG" alt="VolatilX Logo">
            <span>VolatilX</span>
        </a>
        <div class="nav-links">
            <a href="/analyze">AI Insights</a>
            <a href="/action-center" class="active">Action Center</a>
            <a href="/report-center">Report Center</a>
            <a href="/subscribe">Plans</a>
            <a href="/settings">Settings</a>
            <span>{{ user.email }}</span>
            <a href="/logout">Logout</a>
        </div>
    </div>

    <main class="action-center">
        <div id="action-center2-root" data-react-root></div>
        <header class="action-center__header action-center__header--sticky" data-sticky-header>
            <div>
                <h1>Action Center</h1>
                <p>Your AI-powered trading cockpit &mdash; real-time signals, levels, and actions.</p>
                {% if primary_dashboard %}
                {% set primary_payload = primary_dashboard.action_data %}
                {% set primary_symbol = primary_payload.symbol if primary_payload and primary_payload.symbol else (primary_dashboard.symbol_display if primary_dashboard and primary_dashboard.symbol_display else primary_dashboard.symbol) %}
                <p class="action-center__meta" data-header-meta hidden></p>
                {% endif %}
            </div>
            <div class="action-controls action-controls--simple">
                <label class="toggle" for="autoRefreshToggle">
                    <input type="checkbox" id="autoRefreshToggle" name="autoupdate" value="1" checked>
                    <span>Auto-update</span>
                </label>
            </div>
        </header>

        {% if dashboards %}
        <section class="action-dashboards" data-dashboard-list>
            {% for dashboard in dashboards %}
            {% set payload = dashboard.action_data %}
            {% set primary_action = payload.primary_action if payload and payload.primary_action else None %}
            {% set gauges = payload.gauges if payload and payload.gauges else None %}
            {% set radar = payload.radar if payload and payload.radar else None %}
            {% set s2 = radar.s2 if radar and radar.s2 else None %}
            {% set s1 = radar.s1 if radar and radar.s1 else None %}
            {% set r1 = radar.r1 if radar and radar.r1 else None %}
            {% set r2 = radar.r2 if radar and radar.r2 else None %}
            {% set price_info = radar.price if radar and radar.price else None %}
            {% set price_value = price_info.value if price_info and price_info.value else (payload.latest_price if payload and payload.latest_price else 'N/A') %}
            {% set gauge_min_label = s2.value if s2 and s2.value else (s1.value if s1 and s1.value else price_value) %}
            {% set gauge_max_label = r2.value if r2 and r2.value else (r1.value if r1 and r1.value else price_value) %}
            {% set scenarios = payload.scenarios if payload and payload.scenarios else [] %}
            {% set trade_plan = payload.trade_plan if payload and payload.trade_plan else None %}
            {% set buy_plan = trade_plan.buy if trade_plan and trade_plan.buy else None %}
            {% set sell_plan = trade_plan.sell if trade_plan and trade_plan.sell else None %}
            {% set no_trade_zones = trade_plan.no_trade_zones if trade_plan and trade_plan.no_trade_zones else [] %}
            {% set risk_notes = trade_plan.risk_notes if trade_plan and trade_plan.risk_notes else [] %}
            {% set position_size = trade_plan.position_size if trade_plan and trade_plan.position_size else 'N/A' %}
            {% set trade_summary = dashboard.strategy_summary if dashboard.strategy_summary else (trade_plan.summary if trade_plan and trade_plan.summary else None) %}
            {% set alerts = payload.alerts if payload and payload.alerts else [] %}
            {% set tags = payload.tags if payload and payload.tags else [] %}
            {% set dashboard_timeframe = dashboard.timeframe if dashboard.timeframe else timeframe %}
            {% set dashboard_intent = dashboard.intent if dashboard.intent else intent %}
            {% set display_symbol = dashboard.symbol_display if dashboard.symbol_display else dashboard.symbol %}
            <article class="action-dashboard" data-dashboard data-dashboard-symbol="{{ dashboard.symbol }}" data-expanded="false">
                <div class="action-dashboard__summary">
                    <div class="action-dashboard__summary-shell">
                        <div class="action-dashboard__summary-head">
                            <div class="action-dashboard__summary-head-col action-dashboard__summary-head-col--identity">
                                <div class="action-dashboard__summary-symbol-row">
                                    <span class="traffic-light traffic-light--{{ payload.traffic_light if payload and payload.traffic_light else 'wait' }} traffic-light--mini action-dashboard__summary-traffic" data-dashboard-traffic role="img" aria-label="{{ (payload.traffic_light if payload and payload.traffic_light else 'wait')|title }} signal"></span>
                                    <span class="action-dashboard__summary-symbol">{{ display_symbol }}</span>
                                </div>
                                <span class="action-dashboard__summary-strategy" data-summary-strategy>{{ dashboard_timeframe|title }} Trading &middot; {{ dashboard_intent|title }}</span>
                                <div class="action-dashboard__summary-controls" data-dashboard-config>
                                    <label class="summary-control">
                                        <span>Time Frame</span>
                                        <select data-dashboard-timeframe aria-label="Select timeframe for {{ display_symbol }}">
                                            <option value="day"{% if dashboard_timeframe == 'day' %} selected{% endif %}>Day</option>
                                            <option value="swing"{% if dashboard_timeframe == 'swing' %} selected{% endif %}>Swing</option>
                                            <option value="long"{% if dashboard_timeframe == 'long' %} selected{% endif %}>Long</option>
                                        </select>
                                    </label>
                                    <label class="summary-control">
                                        <span>Intent</span>
                                        <select data-dashboard-intent aria-label="Select intent for {{ display_symbol }}">
                                            <option value="buy"{% if dashboard_intent == 'buy' %} selected{% endif %}>Buy</option>
                                            <option value="sell"{% if dashboard_intent == 'sell' %} selected{% endif %}>Sell</option>
                                        </select>
                                    </label>
                                </div>
                                <div class="action-dashboard__callout">
                                    <span class="action-dashboard__callout-label">What should I do?</span>
                                    <span class="action-dashboard__callout-title" data-summary-title>{{ primary_action.title if primary_action else 'N/A' }}</span>
                                    <span class="action-dashboard__callout-subtitle" data-summary-subtitle>{{ primary_action.subtitle if primary_action and primary_action.subtitle else 'No guidance yet.' }}</span>
                                </div>
                            </div>
                            <div class="action-dashboard__summary-head-col action-dashboard__summary-head-col--gauge">
                                <div class="level-gauge" data-gauge-root>
                                    <div class="level-gauge__body">
                                        <canvas class="level-gauge__canvas" width="320" height="160" data-gauge-canvas role="img" aria-label="Price gauge"></canvas>
                                        <div class="level-gauge__needle-value" data-gauge-price>{{ price_value or 'N/A' }}</div>
                                    </div>
                                    <span class="level-gauge__range" data-gauge-range>{{ gauge_min_label or 'N/A' }} &ndash; {{ gauge_max_label or 'N/A' }}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="action-dashboard__summary-toggle" data-dashboard-toggle aria-expanded="false" aria-label="Expand {{ display_symbol }} dashboard">
                        <span class="action-dashboard__toggle-indicator" aria-hidden="true"></span>
                    </button>
                </div>
                <div class="action-dashboard__body" data-dashboard-body hidden>
                    <div class="action-dashboard__content"{% if not payload %} hidden{% endif %} data-dashboard-content>
                        <section class="action-card" data-section="primary">
                            <div class="action-card__label">What should I do?</div>
                            <div class="action-card__body">
                                <div class="action-card__status action-card__status--{{ primary_action.icon if primary_action and primary_action.icon else 'neutral' }}">
                                    <span class="action-card__status-title" data-primary-title>{{ primary_action.title if primary_action else 'N/A' }}</span>
                                    <span class="action-card__status-subtitle" data-primary-subtitle>{{ primary_action.subtitle if primary_action and primary_action.subtitle else '' }}</span>
                                </div>
                                <div class="action-card__details" data-primary-explanation>
                                    {% set explanation_lines = primary_action.explanation if primary_action and primary_action.explanation else [] %}
                                    {% if explanation_lines %}
                                    {% for line in explanation_lines %}
                                    <p>{{ line }}</p>
                                    {% endfor %}
                                    {% else %}
                                    <p>No narrative guidance available yet.</p>
                                    {% endif %}
                                </div>
                                <div class="confidence-meter" data-confidence="{{ primary_action.confidence_score if primary_action and primary_action.confidence_score else 0 }}">
                                    <div class="confidence-meter__label" data-primary-confidence>
                                        Confidence {{ primary_action.confidence if primary_action and primary_action.confidence else 'N/A' }}
                                    </div>
                                    <div class="confidence-meter__bar"><span data-confidence-bar data-width="{{ primary_action.confidence_score if primary_action and primary_action.confidence_score else 0 }}"></span></div>
                                </div>
                            </div>
                        </section>

                        <section class="gauge-cluster" data-dashboard-gauges>
                            {% set bias = gauges.bias if gauges and gauges.bias else None %}
                            {% set volatility = gauges.volatility if gauges and gauges.volatility else None %}
                            {% set signal = gauges.signal if gauges and gauges.signal else None %}
                            <div class="gauge" data-gauge="bias" style="--gauge-value: {{ bias.score if bias and bias.score is not none else 0 }}">
                                <div class="gauge__dial"></div>
                                <div class="gauge__content">
                                    <span class="gauge__label">Bias</span>
                                    <strong>{{ bias.label if bias and bias.label else 'N/A' }}</strong>
                                </div>
                            </div>
                            <div class="gauge" data-gauge="volatility" style="--gauge-value: {{ volatility.score if volatility and volatility.score is not none else 0 }}">
                                <div class="gauge__dial"></div>
                                <div class="gauge__content">
                                    <span class="gauge__label">Volatility</span>
                                    <strong>{{ volatility.label if volatility and volatility.label else 'N/A' }}</strong>
                                </div>
                            </div>
                            <div class="gauge" data-gauge="signal" style="--gauge-value: {{ signal.score if signal and signal.score is not none else 0 }}">
                                <div class="gauge__dial"></div>
                                <div class="gauge__content">
                                    <span class="gauge__label">Signal Strength</span>
                                    <strong>{{ signal.label if signal and signal.label else 'N/A' }}</strong>
                                </div>
                            </div>
                        </section>

                        <section class="level-radar" aria-label="Support and resistance radar">
                            <div class="level-radar__track" data-radar-track style="--price-position: {{ price_info.position if price_info and price_info.position is not none else 0.5 }}">
                                <div class="level-marker level-marker--s2">
                                    <span class="level-marker__title">Support 2</span>
                                    <span class="level-marker__value" data-radar-value="s2">{{ s2.value if s2 and s2.value else 'N/A' }}</span>
                                    <span class="level-marker__delta" data-radar-delta="s2">{{ s2.distance if s2 and s2.distance else '' }}</span>
                                </div>
                                <div class="level-marker level-marker--s1">
                                    <span class="level-marker__title">Support 1</span>
                                    <span class="level-marker__value" data-radar-value="s1">{{ s1.value if s1 and s1.value else 'N/A' }}</span>
                                    <span class="level-marker__delta" data-radar-delta="s1">{{ s1.distance if s1 and s1.distance else '' }}</span>
                                </div>
                                <div class="level-marker level-marker--price">
                                    <span class="level-marker__title">Price</span>
                                    <span class="level-marker__value" data-radar-value="price">{{ price_value or 'N/A' }}</span>
                                </div>
                                <div class="level-marker level-marker--r1">
                                    <span class="level-marker__title">Resistance 1</span>
                                    <span class="level-marker__value" data-radar-value="r1">{{ r1.value if r1 and r1.value else 'N/A' }}</span>
                                    <span class="level-marker__delta" data-radar-delta="r1">{{ r1.distance if r1 and r1.distance else '' }}</span>
                                </div>
                                <div class="level-marker level-marker--r2">
                                    <span class="level-marker__title">Resistance 2</span>
                                    <span class="level-marker__value" data-radar-value="r2">{{ r2.value if r2 and r2.value else 'N/A' }}</span>
                                    <span class="level-marker__delta" data-radar-delta="r2">{{ r2.distance if r2 and r2.distance else '' }}</span>
                                </div>
                            </div>
                            <div class="traffic-light traffic-light--{{ payload.traffic_light if payload and payload.traffic_light else 'wait' }}" data-dashboard-traffic-expanded aria-label="Market zone indicator">
                                <span data-traffic-label>{{ (payload.traffic_light if payload and payload.traffic_light else 'wait')|upper }}</span>
                            </div>
                        </section>

                        <section class="scenario-cards" data-dashboard-scenarios>
                            {% if scenarios %}
                            {% for scenario in scenarios %}
                            <article class="scenario-card scenario-card--{{ scenario.icon }}">
                                <h3>{{ scenario.title }}</h3>
                                <p>{{ scenario.body }}</p>
                            </article>
                            {% endfor %}
                            {% else %}
                            <article class="scenario-card scenario-card--range">
                                <h3>No scenarios yet</h3>
                                <p>Fresh scenarios will appear once the analysis is regenerated.</p>
                            </article>
                            {% endif %}
                        </section>

                        <section class="trade-plan">
                            <header>
                                <h2>Auto-generated trade plan</h2>
                                {% if trade_summary %}
                                <p data-strategy-summary>{{ trade_summary }}</p>
                                {% else %}
                                <p data-strategy-summary hidden></p>
                                {% endif %}
                            </header>
                            <div class="trade-plan__grid">
                                <div class="plan-subsection plan-subsection--buy" data-plan-buy>
                                    <div class="plan-subsection__title">Buy Setup</div>
                                    <div class="plan-subsection__content">
                                        <div class="plan-field">
                                            <strong>Entry</strong>
                                            <span data-plan-buy-entry>{{ buy_plan.entry if buy_plan and buy_plan.entry else 'N/A' }}</span>
                                        </div>
                                        <div class="plan-field">
                                            <strong>Stop</strong>
                                            <span data-plan-buy-stop>{{ buy_plan.stop if buy_plan and buy_plan.stop else 'N/A' }}</span>
                                        </div>
                                        <div class="plan-field">
                                            <strong>Targets</strong>
                                            <ul class="plan-list" data-plan-buy-targets>
                                                {% if buy_plan and buy_plan.targets %}
                                                {% for target in buy_plan.targets %}
                                                <li>{{ target }}</li>
                                                {% endfor %}
                                                {% else %}
                                                <li>N/A</li>
                                                {% endif %}
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="plan-subsection plan-subsection--sell" data-plan-sell>
                                    <div class="plan-subsection__title">Sell Setup</div>
                                    <div class="plan-subsection__content">
                                        <div class="plan-field">
                                            <strong>Entry</strong>
                                            <span data-plan-sell-entry>{{ sell_plan.entry if sell_plan and sell_plan.entry else 'N/A' }}</span>
                                        </div>
                                        <div class="plan-field">
                                            <strong>Stop</strong>
                                            <span data-plan-sell-stop>{{ sell_plan.stop if sell_plan and sell_plan.stop else 'N/A' }}</span>
                                        </div>
                                        <div class="plan-field">
                                            <strong>Targets</strong>
                                            <ul class="plan-list" data-plan-sell-targets>
                                                {% if sell_plan and sell_plan.targets %}
                                                {% for target in sell_plan.targets %}
                                                <li>{{ target }}</li>
                                                {% endfor %}
                                                {% else %}
                                                <li>N/A</li>
                                                {% endif %}
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="plan-subsection plan-subsection--neutral" data-plan-no-trade>
                                    <div class="plan-subsection__title">No-Trade Zones</div>
                                    <div class="plan-subsection__content">
                                        <div class="plan-field">
                                            <strong>Zones</strong>
                                            <ul class="plan-list" data-plan-no-trade>
                                                {% if no_trade_zones %}
                                                {% for zone in no_trade_zones %}
                                                <li>{{ zone.label if zone and zone.label else ((zone.min or 'N/A') ~ ' – ' ~ (zone.max or 'N/A')) }}</li>
                                                {% endfor %}
                                                {% else %}
                                                <li>No restricted ranges.</li>
                                                {% endif %}
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="plan-subsection plan-subsection--meta">
                                    <div class="plan-subsection__title">Position &amp; Risk</div>
                                    <div class="plan-subsection__content">
                                        <div class="plan-field">
                                            <strong>Position Size</strong>
                                            <span data-plan-size>{{ position_size }}</span>
                                        </div>
                                        <div class="plan-field">
                                            <strong>Risk Notes</strong>
                                            <ul class="plan-list" data-plan-risk>
                                                {% if risk_notes %}
                                                {% for note in risk_notes %}
                                                <li>{{ note }}</li>
                                                {% endfor %}
                                                {% else %}
                                                <li>No additional risk notes.</li>
                                                {% endif %}
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <div class="action-lower">
                            <div class="alerts">
                                <h2>Suggested alerts</h2>
                                <ul data-alerts-list>
                                    {% if alerts %}
                                    {% for alert in alerts %}
                                    <li><button type="button" class="alert-button" data-alert="{{ alert }}">{{ alert }}</button></li>
                                    {% endfor %}
                                    {% else %}
                                    <li>No alerts suggested.</li>
                                    {% endif %}
                                </ul>
                            </div>
                            <div class="level-gauge level-gauge--full" data-gauge-root>
                                <div class="level-gauge__header">
                                    <h2>Price range gauge</h2>
                                    <span class="level-gauge__range" data-gauge-range>{{ gauge_min_label or 'N/A' }} &ndash; {{ gauge_max_label or 'N/A' }}</span>
                                </div>
                                <div class="level-gauge__body">
                                    <canvas class="level-gauge__canvas" width="320" height="160" data-gauge-canvas role="img" aria-label="Price gauge"></canvas>
                                    <div class="level-gauge__needle-value" data-gauge-price>{{ price_value or 'N/A' }}</div>
                                </div>
                            </div>
                        </div>

                        <footer class="action-tags" data-dashboard-tags>
                            {% if tags %}
                            {% for tag in tags %}
                            <span>{{ tag }}</span>
                            {% endfor %}
                            {% else %}
                            <span>No tags available yet.</span>
                            {% endif %}
                        </footer>
                    </div>
                    <div class="action-dashboard__empty"{% if payload %} hidden{% endif %} data-dashboard-empty>
                        <p data-dashboard-empty-message>{{ dashboard.error_message or 'No recent AI analysis found for this symbol. Try running a new multi-agent analysis first.' }}</p>
                    </div>
                </div>
            </article>
            {% endfor %}
        </section>
        {% else %}
        <div class="action-center__empty">
            <p>No tracked symbols available for the Action Center. Follow a symbol or run an analysis to get started.</p>
        </div>
        {% endif %}
    </main>

    {% if dashboards_json %}
    <script id="actionCenterDashboards" type="application/json">{{ dashboards_json | safe }}</script>
    {% endif %}
    {% if principal_plan_json %}
    <script id="actionCenterPrincipalPlan" type="application/json">{{ principal_plan_json | safe }}</script>
    {% endif %}
    <script>
    (function () {
        const planSource = document.getElementById('actionCenterPrincipalPlan');
        if (planSource) {
            try {
                const planPayload = JSON.parse(planSource.textContent || '{}');
                window.__ACTION_CENTER_PRINCIPAL_PLAN__ = planPayload;
            } catch (error) {
                console.warn('Failed to parse Action Center principal plan payload', error);
            }
        }

        const dataSource = document.getElementById('actionCenterDashboards');
        if (!dataSource) {
            return;
        }

        let dashboardsPayload;
        try {
            dashboardsPayload = JSON.parse(dataSource.textContent || '[]');
        } catch (error) {
            console.warn('Failed to parse Action Center dashboards payload', error);
            dashboardsPayload = [];
        }

        if (!Array.isArray(dashboardsPayload)) {
            dashboardsPayload = [];
        }

        const dashboardRoot = document.querySelector('[data-dashboard-list]');
        if (!dashboardRoot) {
            return;
        }

        const bodyNode = document.body;
        const livePriceEnabled = Boolean(bodyNode && bodyNode.dataset && bodyNode.dataset.livePrice === 'true');
        const autoToggle = document.querySelector('#autoRefreshToggle');
        const headerMeta = document.querySelector('[data-header-meta]');
        const fallbackSymbol = '{{ symbol }}';
        const defaultSymbol = dashboardsPayload.length ? (dashboardsPayload[0].symbol || fallbackSymbol) : fallbackSymbol;

        const degToRad = (deg) => (deg * Math.PI) / 180;

        function normaliseTimeframe(value) {
            const slug = (value == null ? '' : String(value)).trim().toLowerCase();
            if (slug === 'swing') return 'swing';
            if (slug === 'long') return 'long';
            return 'day';
        }

        function normaliseIntent(value) {
            const slug = (value == null ? '' : String(value)).trim().toLowerCase();
            return slug === 'sell' ? 'sell' : 'buy';
        }

        const gaugeColors = {
            belowS2: '#b91c1c',
            betweenSupports: '#f97316',
            midZone: '#facc15',
            betweenResistances: '#22c55e',
            aboveR2: '#15803d',
        };

        const gaugeZoneFill = {
            belowS2: 'rgba(59, 15, 20, 0.72)',
            betweenSupports: 'rgba(127, 29, 29, 0.68)',
            midZone: 'rgba(180, 83, 9, 0.58)',
            betweenResistances: 'rgba(15, 118, 110, 0.6)',
            aboveR2: 'rgba(6, 78, 59, 0.62)',
        };

        const gaugeZoneLabels = {
            belowS2: 'Below Support 2',
            betweenSupports: 'Between Supports',
            midZone: 'Mid Zone',
            betweenResistances: 'Between Resistances',
            aboveR2: 'Above Resistance 2',
        };

        const defaultTimeframe = normaliseTimeframe('{{ timeframe }}');
        const defaultIntent = normaliseIntent('{{ intent }}');

        function formatStrategyLabel(timeframe, intent) {
            const timeframeLabels = {
                day: 'Day Trading',
                swing: 'Swing Trading',
                long: 'Long Trading',
            };
            const intentLabels = {
                buy: 'Buy',
                sell: 'Sell',
            };
            const timeframeKey = normaliseTimeframe(timeframe);
            const intentKey = normaliseIntent(intent);
            return `${timeframeLabels[timeframeKey] || 'Day Trading'} · ${intentLabels[intentKey] || 'Buy'}`;
        }

        const dashState = {
            dashboards: new Map(),
            primarySymbol: dashboardsPayload.length ? dashboardsPayload[0].symbol || defaultSymbol : defaultSymbol,
            defaultTimeframe,
            defaultIntent,
            refreshTimer: null,
            livePriceTimer: null,
            resizeTimer: null,
        };

        function updateStrategyLabel(record) {
            if (!record || !record.node) return;
            const labelNode = record.node.querySelector('[data-summary-strategy]');
            if (!labelNode) return;
            const timeframe = record.meta && record.meta.timeframe ? record.meta.timeframe : dashState.defaultTimeframe;
            const intent = record.meta && record.meta.intent ? record.meta.intent : dashState.defaultIntent;
            labelNode.textContent = formatStrategyLabel(timeframe, intent);
        }

        function applyConfigControlValues(record) {
            if (!record || !record.node) return;
            const timeframeSelect = record.node.querySelector('[data-dashboard-timeframe]');
            const intentSelect = record.node.querySelector('[data-dashboard-intent]');
            const timeframe = record.meta && record.meta.timeframe ? record.meta.timeframe : dashState.defaultTimeframe;
            const intent = record.meta && record.meta.intent ? record.meta.intent : dashState.defaultIntent;
            if (timeframeSelect && timeframeSelect.value !== timeframe) {
                timeframeSelect.value = timeframe;
            }
            if (intentSelect && intentSelect.value !== intent) {
                intentSelect.value = intent;
            }
        }

        function formatPrice(value) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return null;
            }
            return value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function parseNumeric(value) {
            if (typeof value === 'number') {
                return Number.isFinite(value) ? value : null;
            }
            if (typeof value === 'string') {
                const cleaned = value.replace(/,/g, '').trim();
                if (!cleaned) return null;
                const parsed = Number(cleaned);
                return Number.isFinite(parsed) ? parsed : null;
            }
            return null;
        }

        function updateTrafficLight(element, status) {
            if (!element) return;
            const next = status || 'wait';
            element.classList.remove('traffic-light--buy', 'traffic-light--sell', 'traffic-light--wait');
            element.classList.add(`traffic-light--${next}`);
            const readable = next.charAt(0).toUpperCase() + next.slice(1);
            element.setAttribute('aria-label', `${readable} signal`);
            element.setAttribute('title', readable);
            const label = element.querySelector('[data-traffic-label]');
            if (label) {
                label.textContent = next.toUpperCase();
            }
        }

        function buildGaugeConfig(payload) {
            if (!payload) return null;
            const radar = payload.radar || {};
            const values = {
                s2: parseNumeric(radar.s2 && radar.s2.value),
                s1: parseNumeric(radar.s1 && radar.s1.value),
                r1: parseNumeric(radar.r1 && radar.r1.value),
                r2: parseNumeric(radar.r2 && radar.r2.value),
                price:
                    typeof payload.latest_price_value === 'number' && Number.isFinite(payload.latest_price_value)
                        ? payload.latest_price_value
                        : parseNumeric(radar.price && radar.price.value),
            };

            const anchors = {
                min: Math.PI,
                s2: degToRad(152.5),
                s1: degToRad(112.5),
                r1: degToRad(67.5),
                r2: degToRad(22.5),
                max: 0,
            };

            const formatted = {
                s2: radar.s2 && radar.s2.value ? radar.s2.value : null,
                s1: radar.s1 && radar.s1.value ? radar.s1.value : null,
                r1: radar.r1 && radar.r1.value ? radar.r1.value : null,
                r2: radar.r2 && radar.r2.value ? radar.r2.value : null,
                price:
                    (radar.price && radar.price.value)
                    || payload.latest_price
                    || (typeof values.price === 'number' && Number.isFinite(values.price) ? formatPrice(values.price) : null),
            };

            const levelKeys = ['s2', 's1', 'r1', 'r2'];
            const points = levelKeys
                .map((key) => (typeof values[key] === 'number' && Number.isFinite(values[key]) ? { key, value: values[key], angle: anchors[key] } : null))
                .filter(Boolean)
                .sort((a, b) => a.value - b.value);

            if (!points.length && !(typeof values.price === 'number' && Number.isFinite(values.price))) {
                return null;
            }

            const spanHeuristic = (() => {
                if (points.length >= 2) {
                    return Math.max(1, Math.abs(points[points.length - 1].value - points[0].value) * 0.1);
                }
                if (points.length === 1 && typeof values.price === 'number' && Number.isFinite(values.price)) {
                    return Math.max(1, Math.abs(values.price - points[0].value) * 0.5);
                }
                if (points.length === 1) {
                    return Math.max(1, Math.abs(points[0].value) * 0.1);
                }
                if (typeof values.price === 'number' && Number.isFinite(values.price)) {
                    return Math.max(1, Math.abs(values.price) * 0.1);
                }
                return 1;
            })();

            const lowerBaseline = points.length ? points[0].value : values.price;
            const upperBaseline = points.length ? points[points.length - 1].value : values.price;
            const fallbackLower = typeof lowerBaseline === 'number' ? lowerBaseline - spanHeuristic : -spanHeuristic;
            const fallbackUpper = typeof upperBaseline === 'number' ? upperBaseline + spanHeuristic : spanHeuristic;

            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

            const resolveAngleForPrice = (priceValue) => {
                if (!(typeof priceValue === 'number' && Number.isFinite(priceValue)) || !points.length) {
                    return anchors.s1;
                }
                if (priceValue <= points[0].value) {
                    const ratio = (priceValue - fallbackLower) / ((points[0].value - fallbackLower) || 1);
                    return anchors.min + (points[0].angle - anchors.min) * clamp(ratio, 0, 1);
                }
                for (let idx = 0; idx < points.length - 1; idx += 1) {
                    const current = points[idx];
                    const next = points[idx + 1];
                    if (priceValue <= next.value) {
                        const ratio = (priceValue - current.value) / ((next.value - current.value) || 1);
                        return current.angle + (next.angle - current.angle) * clamp(ratio, 0, 1);
                    }
                }
                const last = points[points.length - 1];
                const ratio = (priceValue - last.value) / ((fallbackUpper - last.value) || 1);
                return last.angle + (anchors.max - last.angle) * clamp(ratio, 0, 1);
            };

            const priceAngle = resolveAngleForPrice(values.price);

            const determineZone = () => {
                const priceVal = values.price;
                const s2Val = values.s2;
                const s1Val = values.s1;
                const r1Val = values.r1;
                const r2Val = values.r2;

                if (!(typeof priceVal === 'number' && Number.isFinite(priceVal))) {
                    return 'midZone';
                }
                if (typeof s2Val === 'number' && Number.isFinite(s2Val) && priceVal < s2Val) {
                    return 'belowS2';
                }
                if (typeof s1Val === 'number' && Number.isFinite(s1Val) && priceVal < s1Val) {
                    return 'betweenSupports';
                }
                if (typeof r1Val === 'number' && Number.isFinite(r1Val) && priceVal <= r1Val) {
                    return 'midZone';
                }
                if (typeof r2Val === 'number' && Number.isFinite(r2Val) && priceVal <= r2Val) {
                    return 'betweenResistances';
                }
                if (!(typeof r2Val === 'number' && Number.isFinite(r2Val)) && typeof r1Val === 'number' && Number.isFinite(r1Val) && priceVal > r1Val) {
                    return 'betweenResistances';
                }
                return 'aboveR2';
            };

            const rangeMinCandidate = typeof values.s2 === 'number' && Number.isFinite(values.s2)
                ? values.s2
                : typeof values.s1 === 'number' && Number.isFinite(values.s1)
                ? values.s1
                : values.price;
            const rangeMaxCandidate = typeof values.r2 === 'number' && Number.isFinite(values.r2)
                ? values.r2
                : typeof values.r1 === 'number' && Number.isFinite(values.r1)
                ? values.r1
                : values.price;

            const resolvedMinValue = typeof rangeMinCandidate === 'number' && Number.isFinite(rangeMinCandidate)
                ? rangeMinCandidate
                : fallbackLower;
            const resolvedMaxValue = typeof rangeMaxCandidate === 'number' && Number.isFinite(rangeMaxCandidate)
                ? rangeMaxCandidate
                : fallbackUpper;
            const formatOrNull = (num) => (typeof num === 'number' && Number.isFinite(num) ? formatPrice(num) : null);

            return {
                values,
                formatted,
                anchors,
                segments: [
                    { key: 'belowS2', start: anchors.min, end: anchors.s2, color: gaugeColors.belowS2 },
                    { key: 'betweenSupports', start: anchors.s2, end: anchors.s1, color: gaugeColors.betweenSupports },
                    { key: 'midZone', start: anchors.s1, end: anchors.r1, color: gaugeColors.midZone },
                    { key: 'betweenResistances', start: anchors.r1, end: anchors.r2, color: gaugeColors.betweenResistances },
                    { key: 'aboveR2', start: anchors.r2, end: anchors.max, color: gaugeColors.aboveR2 },
                ],
                needleAngle: priceAngle,
                zone: determineZone(),
                range: {
                    minValue: resolvedMinValue,
                    maxValue: resolvedMaxValue,
                    minLabel: formatted.s2 || formatted.s1 || formatted.price || formatOrNull(resolvedMinValue) || 'N/A',
                    maxLabel: formatted.r2 || formatted.r1 || formatted.price || formatOrNull(resolvedMaxValue) || 'N/A',
                },
            };
        }

        function drawGauge(canvas, config) {
            if (!canvas || !config) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const ratio = window.devicePixelRatio || 1;
            const width = canvas.clientWidth || canvas.width || 0;
            const height = canvas.clientHeight || canvas.height || 0;
            if (!width || !height) return;

            const displayWidth = Math.round(width * ratio);
            const displayHeight = Math.round(height * ratio);
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(ratio, ratio);

            const centerX = width / 2;
            const centerY = height - 10;
            const baseRadius = Math.min(width / 2 - 20, height - 28);
            const radius = Math.max(48, baseRadius);
            const lineWidth = Math.max(12, radius * 0.22);
            let stripeOuterRadius = Math.min(centerY - 4, radius + lineWidth * 0.48);
            let stripeInnerRadius = Math.max(radius + lineWidth * 0.1, stripeOuterRadius - lineWidth * 0.34);
            if (stripeInnerRadius >= stripeOuterRadius) {
                stripeInnerRadius = Math.max(radius + lineWidth * 0.08, stripeOuterRadius - 6);
            }
            stripeOuterRadius = Math.max(stripeOuterRadius, stripeInnerRadius + 4);
            const effectiveStripeThickness = Math.max(4, stripeOuterRadius - stripeInnerRadius);

            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineWidth = lineWidth;

            ctx.save();
            if (typeof ctx.createConicGradient === 'function') {
                const stripeGradient = ctx.createConicGradient(Math.PI, centerX, centerY);
                stripeGradient.addColorStop(0, '#581c1c');
                stripeGradient.addColorStop(0.18, '#7f1d1d');
                stripeGradient.addColorStop(0.36, '#b45309');
                stripeGradient.addColorStop(0.5, '#0f766e');
                stripeGradient.addColorStop(0.82, '#0f766e');
                stripeGradient.addColorStop(1, '#064e3b');
                ctx.fillStyle = stripeGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, stripeOuterRadius, Math.PI, 0, true);
                ctx.arc(centerX, centerY, stripeInnerRadius, 0, Math.PI, false);
                ctx.closePath();
                ctx.fill();
            } else {
                const fallbackGradient = ctx.createLinearGradient(centerX - radius, centerY, centerX + radius, centerY);
                fallbackGradient.addColorStop(0, '#581c1c');
                fallbackGradient.addColorStop(0.5, '#b45309');
                fallbackGradient.addColorStop(1, '#064e3b');
                ctx.strokeStyle = fallbackGradient;
                ctx.lineWidth = effectiveStripeThickness;
                ctx.beginPath();
                ctx.arc(centerX, centerY, stripeInnerRadius + effectiveStripeThickness / 2, Math.PI, 0, true);
                ctx.stroke();
            }
            ctx.restore();

            ctx.strokeStyle = 'rgba(15, 23, 42, 0.32)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 0, true);
            ctx.stroke();

            const innerFillRadius = Math.max(0, radius - lineWidth * 0.6);
            const zoneFill = gaugeZoneFill[config.zone] || 'rgba(30, 41, 59, 0.32)';
            ctx.fillStyle = zoneFill;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, innerFillRadius, Math.PI, 0, true);
            ctx.closePath();
            ctx.fill();

            config.segments.forEach((segment) => {
                ctx.strokeStyle = segment.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, segment.start, segment.end, true);
                ctx.stroke();
            });

            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(248, 250, 252, 0.65)';
            const innerRadius = radius - lineWidth / 2 - 6;
            const outerRadius = innerRadius + 10;
            const tickAngles = [config.anchors.min, config.anchors.s2, config.anchors.s1, config.anchors.r1, config.anchors.r2, config.anchors.max];
            tickAngles.forEach((angle) => {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(centerX + cos * innerRadius, centerY - sin * innerRadius);
                ctx.lineTo(centerX + cos * outerRadius, centerY - sin * outerRadius);
                ctx.stroke();
            });

            const labelFontSize = Math.max(12, Math.min(18, width * 0.08));
            const labelRadius = radius - lineWidth * 0.45;
            const renderLevelLabel = (angle, text) => {
                if (!text) return;
                ctx.save();
                ctx.font = `600 ${labelFontSize}px 'Inter', 'Segoe UI', Arial`;
                ctx.fillStyle = 'rgba(241, 245, 249, 0.86)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const x = centerX + Math.cos(angle) * labelRadius;
                const y = centerY - Math.sin(angle) * labelRadius;
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = 'rgba(15, 23, 42, 0.35)';
                ctx.strokeText(text, x, y);
                ctx.fillText(text, x, y);
                ctx.restore();
            };

            renderLevelLabel(config.anchors.s2, config.formatted.s2);
            renderLevelLabel(config.anchors.s1, config.formatted.s1);
            renderLevelLabel(config.anchors.r1, config.formatted.r1);
            renderLevelLabel(config.anchors.r2, config.formatted.r2);

            const needleAngle = typeof config.needleAngle === 'number' ? config.needleAngle : config.anchors.s1;
            const needleLength = radius - lineWidth * 0.68;
            const needleCos = Math.cos(needleAngle);
            const needleSin = Math.sin(needleAngle);
            const needleStartOffset = Math.min(radius * 0.22, lineWidth * 0.85);
            const startXRaw = centerX + needleCos * needleStartOffset;
            const startYRaw = centerY - needleSin * needleStartOffset;
            const endX = centerX + needleCos * needleLength;
            const endY = centerY - needleSin * needleLength;

            ctx.save();
            ctx.shadowColor = 'rgba(253, 230, 138, 0.45)';
            ctx.shadowBlur = 12;
            ctx.strokeStyle = '#fde68a';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(startXRaw, startYRaw);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.restore();

            ctx.fillStyle = '#0f172a';
            ctx.beginPath();
            ctx.arc(centerX, centerY, lineWidth * 0.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fde68a';
            ctx.beginPath();
            ctx.arc(centerX, centerY, lineWidth * 0.24, 0, Math.PI * 2);
            ctx.fill();

            const tipX = centerX + needleCos * (needleLength - 6);
            const tipY = centerY - needleSin * (needleLength - 6);
            ctx.fillStyle = '#fef9c3';
            ctx.beginPath();
            ctx.arc(tipX, tipY, 4, 0, Math.PI * 2);
            ctx.fill();

            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
            const labelX = clamp(startXRaw, width * 0.22, width * 0.78);
            const labelY = clamp(startYRaw, height * 0.38, height * 0.78);
            const parent = canvas.parentElement;
            if (parent) {
                const labelNode = parent.querySelector('[data-gauge-price]');
                if (labelNode) {
                    const percentX = (labelX / width) * 100;
                    const percentY = (labelY / height) * 100;
                    labelNode.style.setProperty('--needle-label-x', `${percentX.toFixed(2)}%`);
                    labelNode.style.setProperty('--needle-label-y', `${percentY.toFixed(2)}%`);
                    labelNode.style.opacity = '1';
                }
            }
        }

        function updateGaugeDisplay(node, payload) {
            const gaugeRoots = node.querySelectorAll('[data-gauge-root]');
            if (!gaugeRoots.length) return;

            const config = buildGaugeConfig(payload);
            gaugeRoots.forEach((root) => {
                const canvas = root.querySelector('[data-gauge-canvas]');
                const rangeLabel = root.querySelector('[data-gauge-range]');
                const priceLabel = root.querySelector('[data-gauge-price]');
                const gaugeContainer = root.classList.contains('level-gauge') ? root : root.closest('.level-gauge');
                if (!config) {
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                        canvas.removeAttribute('data-zone');
                        canvas.setAttribute('aria-label', 'Price gauge unavailable');
                    }
                    if (rangeLabel) {
                        rangeLabel.textContent = 'N/A - N/A';
                    }
                    if (priceLabel) {
                        priceLabel.textContent = 'N/A';
                        priceLabel.style.opacity = '0';
                    }
                    if (gaugeContainer) {
                        gaugeContainer.removeAttribute('data-zone');
                    }
                    return;
                }

                if (rangeLabel) {
                    rangeLabel.textContent = `${config.range.minLabel || 'N/A'} - ${config.range.maxLabel || 'N/A'}`;
                }
                if (priceLabel) {
                    const priceLabelText = config.formatted.price
                        || (payload && payload.radar && payload.radar.price && payload.radar.price.value)
                        || (payload && payload.latest_price)
                        || 'N/A';
                    priceLabel.textContent = priceLabelText;
                    priceLabel.style.opacity = '1';
                }
                if (canvas) {
                    drawGauge(canvas, config);
                    if (config.zone) {
                        canvas.setAttribute('data-zone', config.zone);
                        canvas.setAttribute('aria-label', `Price gauge · ${gaugeZoneLabels[config.zone] || config.zone}`);
                    } else {
                        canvas.removeAttribute('data-zone');
                    }
                }
                if (gaugeContainer) {
                    if (config.zone) {
                        gaugeContainer.setAttribute('data-zone', config.zone);
                    } else {
                        gaugeContainer.removeAttribute('data-zone');
                    }
                }
            });

            if (!payload) {
                return;
            }

            const radar = payload.radar || {};
            if (config && typeof config.range.minValue === 'number' && typeof config.range.maxValue === 'number') {
                payload.chart = payload.chart || {};
                payload.chart.min_value = config.range.minValue;
                payload.chart.max_value = config.range.maxValue;
                payload.chart.min = config.range.minLabel;
                payload.chart.max = config.range.maxLabel;
                if (typeof config.values.price === 'number' && Number.isFinite(config.values.price) && config.range.maxValue !== config.range.minValue) {
                    const span = config.range.maxValue - config.range.minValue;
                    const normalised = Math.max(0, Math.min(1, (config.values.price - config.range.minValue) / span));
                    payload.chart.position = normalised;
                    if (radar.price) {
                        radar.price.position = normalised;
                    }
                }
            }
        }

        function renderList(container, items, createContent) {
            if (!container) return;
            container.innerHTML = '';
            const list = Array.isArray(items) ? items : [];
            if (!list.length) {
                createContent(container, null, true);
                return;
            }
            list.forEach((item) => {
                createContent(container, item, false);
            });
        }

        function updateDashboardContent(record) {
            const { node, payload, meta } = record;
            const hasData = Boolean(payload);
            node.dataset.hasData = hasData ? 'true' : 'false';

            applyConfigControlValues(record);
            updateStrategyLabel(record);

            const summaryTitle = node.querySelector('[data-summary-title]');
            if (summaryTitle) {
                summaryTitle.textContent =
                    (payload && payload.primary_action && payload.primary_action.title)
                        ? payload.primary_action.title
                        : 'N/A';
            }
            const summarySubtitle = node.querySelector('[data-summary-subtitle]');
            if (summarySubtitle) {
                summarySubtitle.textContent =
                    (payload && payload.primary_action && payload.primary_action.subtitle)
                        ? payload.primary_action.subtitle
                        : 'No guidance yet.';
            }

            const trafficStatus = (payload && payload.traffic_light) ? payload.traffic_light : 'wait';
            node.querySelectorAll('[data-dashboard-traffic], [data-dashboard-traffic-expanded]').forEach((traffic) => {
                updateTrafficLight(traffic, trafficStatus);
            });

            const contentContainer = node.querySelector('[data-dashboard-content]');
            const emptyContainer = node.querySelector('[data-dashboard-empty]');
            const emptyMessage = node.querySelector('[data-dashboard-empty-message]');
            if (contentContainer) {
                contentContainer.hidden = !hasData;
            }
            if (emptyContainer) {
                emptyContainer.hidden = hasData;
            }
            if (!hasData && emptyMessage) {
                emptyMessage.textContent = (meta && meta.error) || 'No recent AI analysis found for this symbol. Try running a new multi-agent analysis first.';
            }

            updateGaugeDisplay(node, payload);

            const tradePlan = (payload && payload.trade_plan) || null;

            const summaryNode = node.querySelector('[data-strategy-summary]');
            if (summaryNode) {
                const summaryText = (meta && meta.strategy_summary)
                    || (tradePlan && tradePlan.summary)
                    || '';
                if (summaryText) {
                    summaryNode.textContent = summaryText;
                    summaryNode.hidden = false;
                    if (meta) {
                        meta.strategy_summary = summaryText;
                    }
                } else {
                    summaryNode.hidden = true;
                }
            }

            if (!hasData) {
                return;
            }

            const actionTitle = node.querySelector('[data-primary-title]');
            if (actionTitle && payload.primary_action) {
                actionTitle.textContent = payload.primary_action.title || 'N/A';
            }
            const actionSubtitle = node.querySelector('[data-primary-subtitle]');
            if (actionSubtitle && payload.primary_action) {
                actionSubtitle.textContent = payload.primary_action.subtitle || '';
            }

            const explanationContainer = node.querySelector('[data-primary-explanation]');
            if (explanationContainer) {
                explanationContainer.innerHTML = '';
                const explanation = (payload.primary_action && payload.primary_action.explanation) || [];
                if (explanation.length) {
                    explanation.forEach((line) => {
                        const p = document.createElement('p');
                        p.textContent = line;
                        explanationContainer.appendChild(p);
                    });
                } else {
                    const p = document.createElement('p');
                    p.textContent = 'No narrative guidance available yet.';
                    explanationContainer.appendChild(p);
                }
            }

            const confidenceLabel = node.querySelector('[data-primary-confidence]');
            const confidenceBar = node.querySelector('[data-confidence-bar]');
            if (confidenceLabel && payload.primary_action) {
                confidenceLabel.textContent = `Confidence ${payload.primary_action.confidence || 'N/A'}`;
            }
            if (confidenceBar && payload.primary_action) {
                const score = Math.max(0, Math.min(payload.primary_action.confidence_score || 0, 100));
                confidenceBar.dataset.width = score;
                confidenceBar.style.width = `${score}%`;
            }

            const radarTrack = node.querySelector('[data-radar-track]');
            const radar = payload.radar || {};
            if (radarTrack && radar.price && typeof radar.price.position === 'number') {
                radarTrack.style.setProperty('--price-position', radar.price.position);
            }

            ['s2', 's1', 'price', 'r1', 'r2'].forEach((key) => {
                const valueNode = node.querySelector(`[data-radar-value="${key}"]`);
                const deltaNode = node.querySelector(`[data-radar-delta="${key}"]`);
                const info = radar[key] || {};
                if (valueNode) {
                    valueNode.textContent = info.value || (key === 'price' ? (payload.latest_price || 'N/A') : 'N/A');
                }
                if (deltaNode) {
                    deltaNode.textContent = info.distance || '';
                }
            });

            node.querySelectorAll('[data-dashboard-gauges] .gauge').forEach((gauge) => {
                const key = gauge.getAttribute('data-gauge');
                if (!key || !payload.gauges || !payload.gauges[key]) return;
                const info = payload.gauges[key];
                if (typeof info.score === 'number') {
                    gauge.style.setProperty('--gauge-value', info.score);
                }
                const label = gauge.querySelector('strong');
                if (label && info.label) {
                    label.textContent = info.label;
                }
            });

            const scenariosContainer = node.querySelector('[data-dashboard-scenarios]');
            if (scenariosContainer) {
                scenariosContainer.innerHTML = '';
                const scenarios = payload.scenarios || [];
                if (scenarios.length) {
                    scenarios.forEach((scenario) => {
                        const article = document.createElement('article');
                        article.className = `scenario-card scenario-card--${scenario.icon || 'range'}`;
                        const title = document.createElement('h3');
                        title.textContent = scenario.title || 'Scenario';
                        const body = document.createElement('p');
                        body.textContent = scenario.body || '';
                        article.appendChild(title);
                        article.appendChild(body);
                        scenariosContainer.appendChild(article);
                    });
                } else {
                    const article = document.createElement('article');
                    article.className = 'scenario-card scenario-card--range';
                    const title = document.createElement('h3');
                    title.textContent = 'No scenarios yet';
                    const body = document.createElement('p');
                    body.textContent = 'Fresh scenarios will appear once the analysis is regenerated.';
                    article.appendChild(title);
                    article.appendChild(body);
                    scenariosContainer.appendChild(article);
                }
            }

            const buyPlan = (tradePlan && tradePlan.buy) || null;
            const sellPlan = (tradePlan && tradePlan.sell) || null;
            const zones = (tradePlan && Array.isArray(tradePlan.no_trade_zones)) ? tradePlan.no_trade_zones : [];

            const buySection = node.querySelector('[data-plan-buy]');
            if (buySection) {
                buySection.dataset.hasSetup = buyPlan ? 'true' : 'false';
            }
            const sellSection = node.querySelector('[data-plan-sell]');
            if (sellSection) {
                sellSection.dataset.hasSetup = sellPlan ? 'true' : 'false';
            }
            const zoneSection = node.querySelector('[data-plan-no-trade]');
            if (zoneSection) {
                zoneSection.dataset.hasSetup = zones.length ? 'true' : 'false';
            }

            const buyEntryNode = node.querySelector('[data-plan-buy-entry]');
            if (buyEntryNode) {
                buyEntryNode.textContent = (buyPlan && buyPlan.entry) || 'N/A';
            }
            const buyStopNode = node.querySelector('[data-plan-buy-stop]');
            if (buyStopNode) {
                buyStopNode.textContent = (buyPlan && buyPlan.stop) || 'N/A';
            }
            const buyTargetsList = node.querySelector('[data-plan-buy-targets]');
            renderList(buyTargetsList, (buyPlan && buyPlan.targets) || [], (container, item, empty) => {
                const li = document.createElement('li');
                li.textContent = empty ? 'N/A' : item;
                container.appendChild(li);
            });

            const sellEntryNode = node.querySelector('[data-plan-sell-entry]');
            if (sellEntryNode) {
                sellEntryNode.textContent = (sellPlan && sellPlan.entry) || 'N/A';
            }
            const sellStopNode = node.querySelector('[data-plan-sell-stop]');
            if (sellStopNode) {
                sellStopNode.textContent = (sellPlan && sellPlan.stop) || 'N/A';
            }
            const sellTargetsList = node.querySelector('[data-plan-sell-targets]');
            renderList(sellTargetsList, (sellPlan && sellPlan.targets) || [], (container, item, empty) => {
                const li = document.createElement('li');
                li.textContent = empty ? 'N/A' : item;
                container.appendChild(li);
            });

            const noTradeList = node.querySelector('[data-plan-no-trade]');
            renderList(noTradeList, zones, (container, item, empty) => {
                const li = document.createElement('li');
                if (empty) {
                    li.textContent = 'No restricted ranges.';
                } else {
                    const label = item && item.label;
                    const min = item && item.min;
                    const max = item && item.max;
                    li.textContent = label || `${min || 'N/A'} – ${max || 'N/A'}`;
                }
                container.appendChild(li);
            });

            const planSize = node.querySelector('[data-plan-size]');
            if (planSize) {
                planSize.textContent = (tradePlan && tradePlan.position_size) || 'N/A';
            }

            const riskList = node.querySelector('[data-plan-risk]');
            renderList(riskList, (tradePlan && tradePlan.risk_notes) || [], (container, item, empty) => {
                const li = document.createElement('li');
                li.textContent = empty ? 'No additional risk notes.' : item;
                container.appendChild(li);
            });

            const alertsList = node.querySelector('[data-alerts-list]');
            renderList(alertsList, payload.alerts || [], (container, item, empty) => {
                if (empty) {
                    const li = document.createElement('li');
                    li.textContent = 'No alerts suggested.';
                    container.appendChild(li);
                } else {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'alert-button';
                    button.dataset.alert = item;
                    button.textContent = item;
                    li.appendChild(button);
                    container.appendChild(li);
                }
            });

            const tagsFooter = node.querySelector('[data-dashboard-tags]');
            if (tagsFooter) {
                tagsFooter.innerHTML = '';
                const tags = payload.tags || [];
                if (tags.length) {
                    tags.forEach((tag) => {
                        const span = document.createElement('span');
                        span.textContent = tag;
                        tagsFooter.appendChild(span);
                    });
                } else {
                    const span = document.createElement('span');
                    span.textContent = 'No tags available yet.';
                    tagsFooter.appendChild(span);
                }
            }
        }

        function updatePrimaryMeta(payload) {
            if (!headerMeta) return;
            headerMeta.hidden = true;
            headerMeta.textContent = '';
        }

        function registerDashboard(entry, index) {
            if (!entry || !entry.symbol) return;
            const symbolKey = entry.symbol;
            const escapedSymbol = typeof CSS !== 'undefined' && CSS.escape ? CSS.escape(symbolKey) : symbolKey.replace(/"/g, '\"');
            const node = document.querySelector(`[data-dashboard-symbol="${escapedSymbol}"]`);
            if (!node) return;

            const entryTimeframe = normaliseTimeframe(entry.timeframe || dashState.defaultTimeframe);
            const entryIntent = normaliseIntent(entry.intent || dashState.defaultIntent);

            const record = {
                symbol: symbolKey,
                node,
                payload: entry.action_data || null,
                meta: {
                    error: entry.error_message || null,
                    strategy_summary: entry.strategy_summary || null,
                    report_blob: entry.report_blob || null,
                    timeframe: entryTimeframe,
                    intent: entryIntent,
                },
            };
            dashState.dashboards.set(symbolKey, record);
            updateDashboardContent(record);
            bindConfigControls(record);

            initToggle(node, symbolKey);

            if (index === 0) {
                dashState.primarySymbol = symbolKey || dashState.primarySymbol;
                if (record.payload) {
                    updatePrimaryMeta(record.payload);
                }
            }
        }

        function initToggle(node, symbol) {
            const toggle = node.querySelector('[data-dashboard-toggle]');
            const body = node.querySelector('[data-dashboard-body]');
            if (!toggle || !body) {
                return;
            }
            toggle.addEventListener('click', () => {
                const expanded = toggle.getAttribute('aria-expanded') === 'true';
                const nextExpanded = !expanded;
                toggle.setAttribute('aria-expanded', String(nextExpanded));
                node.dataset.expanded = nextExpanded ? 'true' : 'false';
                body.hidden = !nextExpanded;
                if (nextExpanded) {
                    const record = dashState.dashboards.get(symbol);
                    if (record && record.payload) {
                        requestAnimationFrame(() => {
                            updateGaugeDisplay(node, record.payload);
                        });
                    }
                }
            });
        }

        function bindConfigControls(record) {
            if (!record || !record.node) return;
            const node = record.node;
            const timeframeSelect = node.querySelector('[data-dashboard-timeframe]');
            const intentSelect = node.querySelector('[data-dashboard-intent]');
            const bindNeeded = node.dataset.configBound !== 'true';

            const handleChange = () => {
                const nextTimeframe = timeframeSelect ? timeframeSelect.value : record.meta.timeframe;
                const nextIntent = intentSelect ? intentSelect.value : record.meta.intent;
                refreshDashboard(record.symbol, { timeframe: nextTimeframe, intent: nextIntent });
            };

            if (bindNeeded) {
                if (timeframeSelect) {
                    timeframeSelect.addEventListener('change', handleChange);
                }
                if (intentSelect) {
                    intentSelect.addEventListener('change', handleChange);
                }
                node.dataset.configBound = 'true';
            }

            applyConfigControlValues(record);
        }

        dashboardsPayload.forEach((entry, index) => {
            registerDashboard(entry, index);
        });

        function refreshAllGauges() {
            dashState.dashboards.forEach((record) => {
                if (record.payload) {
                    updateGaugeDisplay(record.node, record.payload);
                }
            });
        }

        window.addEventListener('resize', () => {
            if (dashState.resizeTimer) {
                window.clearTimeout(dashState.resizeTimer);
            }
            dashState.resizeTimer = window.setTimeout(() => {
                refreshAllGauges();
            }, 160);
        });

        async function refreshDashboard(symbol, overrides = {}) {
            const record = dashState.dashboards.get(symbol);
            if (!record) return;

            const nextTimeframe = normaliseTimeframe(overrides.timeframe || (record.meta && record.meta.timeframe) || dashState.defaultTimeframe);
            const nextIntent = normaliseIntent(overrides.intent || (record.meta && record.meta.intent) || dashState.defaultIntent);

            record.meta.timeframe = nextTimeframe;
            record.meta.intent = nextIntent;
            applyConfigControlValues(record);
            updateStrategyLabel(record);

            const params = new URLSearchParams({
                symbol,
                timeframe: nextTimeframe,
                intent: nextIntent,
            });

            try {
                const response = await fetch(`/api/action-center?${params.toString()}`, { headers: { Accept: 'application/json' } });
                if (!response.ok) {
                    if (response.status === 404) {
                        record.payload = null;
                        record.meta.error = 'No recent AI analysis found for this symbol. Try running a new multi-agent analysis first.';
                        updateDashboardContent(record);
                    } else {
                        console.warn('Action Center refresh skipped', response.status);
                    }
                    return;
                }
                const payload = await response.json();
                if (!payload || !payload.action) {
                    return;
                }
                record.payload = payload.action;
                record.meta.error = null;
                if (typeof payload.timeframe === 'string') {
                    record.meta.timeframe = normaliseTimeframe(payload.timeframe);
                }
                if (typeof payload.intent === 'string') {
                    record.meta.intent = normaliseIntent(payload.intent);
                }
                applyConfigControlValues(record);
                updateStrategyLabel(record);
                updateDashboardContent(record);
                if (symbol === dashState.primarySymbol) {
                    updatePrimaryMeta(record.payload);
                }
            } catch (error) {
                console.warn('Failed to refresh Action Center data', error);
            }
        }

        async function refreshAllDashboards() {
            const tasks = [];
            dashState.dashboards.forEach((record) => {
                if (record && record.symbol) {
                    tasks.push(refreshDashboard(record.symbol));
                }
            });
            await Promise.all(tasks);
        }

        async function refreshLivePrice() {
            if (!livePriceEnabled) return;
            const symbol = dashState.primarySymbol || defaultSymbol;
            if (!symbol) return;
            try {
                const response = await fetch(`/api/live-price?symbol=${encodeURIComponent(symbol)}`, { headers: { Accept: 'application/json' } });
                if (response.status === 503) {
                    console.warn('Live price stream unavailable');
                    stopLivePrice();
                    return;
                }
                if (response.status === 202) {
                    return;
                }
                if (!response.ok) {
                    console.warn('Live price request failed', response.status);
                    return;
                }
                const data = await response.json();
                if (!data || typeof data.price !== 'number') {
                    return;
                }
                const record = dashState.dashboards.get(symbol);
                if (!record || !record.payload) {
                    return;
                }
                const formatted = formatPrice(data.price) || String(data.price);
                record.payload.latest_price_value = data.price;
                record.payload.latest_price = formatted;
                record.payload.radar = record.payload.radar || {};
                record.payload.radar.price = record.payload.radar.price || {};
                record.payload.radar.price.value = formatted;
                updateDashboardContent(record);
            } catch (error) {
                console.warn('Failed to refresh live price', error);
            }
        }

        function startAutoRefresh() {
            if (dashState.refreshTimer) return;
            dashState.refreshTimer = window.setInterval(() => {
                refreshAllDashboards();
            }, 30000);
        }

        function stopAutoRefresh() {
            if (!dashState.refreshTimer) return;
            window.clearInterval(dashState.refreshTimer);
            dashState.refreshTimer = null;
        }

        function startLivePrice() {
            if (!livePriceEnabled || dashState.livePriceTimer) return;
            dashState.livePriceTimer = window.setInterval(refreshLivePrice, 7000);
            refreshLivePrice();
        }

        function stopLivePrice() {
            if (!dashState.livePriceTimer) return;
            window.clearInterval(dashState.livePriceTimer);
            dashState.livePriceTimer = null;
        }

        if (autoToggle) {
            autoToggle.addEventListener('change', (event) => {
                if (event.target.checked) {
                    startAutoRefresh();
                    refreshAllDashboards();
                    startLivePrice();
                } else {
                    stopAutoRefresh();
                    stopLivePrice();
                }
            });
        }

        if (autoToggle && autoToggle.checked) {
            startAutoRefresh();
            refreshAllDashboards();
            startLivePrice();
        } else if (livePriceEnabled) {
            refreshLivePrice();
        }
    }());
    </script>
</body>
</html>
