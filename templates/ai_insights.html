<! DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VolatilX - AI Insights</title>
    <!-- Link to your main CSS -->
    <link rel="stylesheet" href="/static/style.css">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BC00YPJSRJ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-BC00YPJSRJ');
    </script>
</head>
<body>

    <div class="header">
        <a class="logo" href="/analyze">
            <img src="/static/VolatilX_Logo.PNG" alt="VolatilX Logo">
            <span>VolatilX</span>
        </a>
        <div class="nav-links">
            <a href="/analyze">AI Insights</a>
            <a href="/dashboard">Dashboard</a>
            <a href="/subscribe">Plans</a>
            <a href="/settings">Settings</a>
            <span>{{ user.email }}</span>
            <a href="/logout">Logout</a>
        </div>
    </div>
    
    <div class="container">
        <div class="trading-panel">
            <h2 class="panel-title">AI Insights</h2>
            <form id="tradingForm">
                <div class="input-group">
                    <label for="marketSelect">Market</label>
                    <select id="marketSelect" name="market" class="market-select">
                        <option value="equity" selected>Stocks (Equities)</option>
                        <option value="crypto">Crypto</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="stockSymbol">Symbol</label>
                    <div class="symbol-input-wrapper">
                        <input type="text" id="stockSymbol" name="stock_symbol" placeholder="Enter stock symbol (e.g., AAPL, TSLA, MSFT)" autocomplete="off" required>
                        <div id="symbolSuggestions" class="symbol-suggestions hidden" role="listbox" aria-label="Ticker suggestions"></div>
                    </div>
                </div>
                <!--
                <div class="checkbox-group">
                    <input type="checkbox" id="useAiAnalysis" name="use_ai_analysis" value="true">
                    <label for="useAiAnalysis">Get AI Investment Strategy</label>
                </div>
                -->
                <div class="checkbox-group">
                    <input type="checkbox" id="usePrincipalAgent" name="use_principal_agent" value="true" checked>
                    <label for="usePrincipalAgent">Generate Multi AI Agent Trading Strategy</label>
                </div>
                <div class="checkbox-group sub-option">
                    <input type="checkbox" id="includePrincipalRaw" name="include_principal_raw_results" value="true" disabled>
                    <label for="includePrincipalRaw">Include expert-level details in plan response</label>
                </div>
                <button type="submit" class="analyze-btn" id="analyzeBtn">
                    Analyze Stock
                </button>
            </form>
        </div>
        
        <div class="results-panel" id="resultsPanel">
            <h2 class="panel-title">Analysis Results</h2>
            
            <div class="tabs hidden" id="resultTabs">
                <div class="tab active" onclick="showTab('technical', event)" id="technicalTab">Technical Analysis</div>
                <div class="tab" onclick="showTab('priceAction', event)" id="priceActionTab" style="display:none;">Price Action Analysis</div>
                <div class="tab" onclick="showTab('principal', event)" id="principalTab" style="display:none;">AI Agents Plan</div>
            </div>

            <div id="symbolMessage" class="result-item info hidden"></div>

            <div id="resultsContent">
                <div id="technicalContent" class="tab-content active"></div>
                <div id="priceActionContent" class="tab-content"></div>
                <div id="principalContent" class="tab-content">
                    <div id="aiContent"></div>
                    <div id="principalPlanContent"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script id="symbolCatalogData" type="application/json">
        {{ (symbol_catalogs or {}) | tojson | safe }}
    </script>

    <script>
        const symbolCatalogElement = document.getElementById('symbolCatalogData');
        let symbolCatalogs = { equity: [], crypto: [] };
        if (symbolCatalogElement) {
            try {
                const parsed = JSON.parse(symbolCatalogElement.textContent || '{}');
                if (Array.isArray(parsed)) {
                    symbolCatalogs.equity = parsed;
                } else if (parsed && typeof parsed === 'object') {
                    for (const [marketKey, entries] of Object.entries(parsed)) {
                        const normalizedKey = String(marketKey || '').toLowerCase();
                        if (Array.isArray(entries) && (normalizedKey === 'equity' || normalizedKey === 'crypto')) {
                            symbolCatalogs[normalizedKey] = entries;
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to parse symbol catalog JSON', error);
                symbolCatalogs = { equity: [], crypto: [] };
            }
            symbolCatalogElement.remove();
        }

        const stockSymbolInput = document.getElementById('stockSymbol');
        const symbolSuggestionsEl = document.getElementById('symbolSuggestions');
        const marketSelect = document.getElementById('marketSelect');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const usePrincipalAgentInput = document.getElementById('usePrincipalAgent');
        const useAiAnalysisInput = document.getElementById('useAiAnalysis');
        const includePrincipalRawInput = document.getElementById('includePrincipalRaw');
        const priceActionTab = document.getElementById('priceActionTab');
        const principalTab = document.getElementById('principalTab');
        const symbolMessageEl = document.getElementById('symbolMessage');
        const LEGAL_NOTE_HTML = '<div class="legal-note">This content is for informational purposes only and does not constitute financial advice.</div>';
        let currentResults = null;
        const MAX_SUGGESTIONS = 9;
        let currentSymbolSuggestions = [];
        let activeSuggestionIndex = -1;
        let currentMarket = marketSelect ? marketSelect.value : 'equity';


        const MARKET_UI_CONFIG = {
            equity: {
                placeholder: 'Enter stock symbol (e.g., AAPL, TSLA, MSFT)',
                buttonText: 'Analyze Stock',
            },
            crypto: {
                placeholder: 'Enter crypto symbol (e.g., BTC/USD, ETH/USD)',
                buttonText: 'Analyze Crypto',
            },
        };

        function getActiveCatalog() {
            return symbolCatalogs[currentMarket] || [];
        }

        function updateMarketUI() {
            const config = MARKET_UI_CONFIG[currentMarket] || MARKET_UI_CONFIG.equity;
            if (stockSymbolInput) {
                stockSymbolInput.placeholder = config.placeholder;
                stockSymbolInput.setAttribute('aria-label', `${config.buttonText} symbol input`);
            }
            if (analyzeBtn) {
                analyzeBtn.textContent = config.buttonText;
            }
        }

        function filterSymbolSuggestions(query) {
            const normalized = (query || '').trim().toLowerCase();
            if (!normalized) {
                return [];
            }

            const tickerMatches = [];
            const otherMatches = [];
            const catalog = getActiveCatalog();

            for (const item of catalog) {
                if (!item || !item.ticker || !item.company) {
                    continue;
                }
                const tickerLower = String(item.ticker).toLowerCase();
                const companyLower = String(item.company).toLowerCase();

                if (tickerLower.startsWith(normalized)) {
                    tickerMatches.push(item);
                } else if (tickerLower.includes(normalized) || companyLower.includes(normalized)) {
                    otherMatches.push(item);
                }
            }

            const combined = tickerMatches.concat(otherMatches);
            const seenTickers = new Set();
            const results = [];

            for (const item of combined) {
                const ticker = item.ticker;
                if (seenTickers.has(ticker)) {
                    continue;
                }
                seenTickers.add(ticker);
                results.push(item);
                if (results.length >= MAX_SUGGESTIONS) {
                    break;
                }
            }

            return results;
        }

        function hideSymbolSuggestions() {
            if (!symbolSuggestionsEl) {
                return;
            }
            symbolSuggestionsEl.classList.add('hidden');
            symbolSuggestionsEl.innerHTML = '';
            currentSymbolSuggestions = [];
            activeSuggestionIndex = -1;
        }

        function renderSymbolSuggestions(items) {
            if (!symbolSuggestionsEl) {
                return;
            }
            if (!items.length) {
                hideSymbolSuggestions();
                return;
            }

            currentSymbolSuggestions = items;
            activeSuggestionIndex = -1;

            symbolSuggestionsEl.innerHTML = items
                .map((item, index) => {
                    const tickerLabel = escapeHtml(String(item.ticker || '').toUpperCase());
                    const companyLabel = escapeHtml(String(item.company || ''));
                    return `<div class="symbol-suggestion" role="option" data-index="${index}" aria-selected="false">`
                        + `<span class="symbol-suggestion__ticker">${tickerLabel}</span>`
                        + `<span class="symbol-suggestion__separator"> - </span>`
                        + `<span class="symbol-suggestion__company">${companyLabel}</span>`
                        + '</div>';
                })
                .join('');

            symbolSuggestionsEl.classList.remove('hidden');
        }

        function setActiveSymbolSuggestion(index) {
            if (!symbolSuggestionsEl) {
                return;
            }
            const options = symbolSuggestionsEl.querySelectorAll('.symbol-suggestion');
            if (!options.length) {
                return;
            }
            options.forEach((option, idx) => {
                if (idx === index) {
                    option.classList.add('active');
                    option.setAttribute('aria-selected', 'true');
                    option.scrollIntoView({ block: 'nearest' });
                } else {
                    option.classList.remove('active');
                    option.setAttribute('aria-selected', 'false');
                }
            });
        }

        function moveSymbolSuggestionFocus(direction) {
            if (!currentSymbolSuggestions.length) {
                return;
            }

            const nextIndex = activeSuggestionIndex + direction;
            if (nextIndex < 0) {
                activeSuggestionIndex = currentSymbolSuggestions.length - 1;
            } else if (nextIndex >= currentSymbolSuggestions.length) {
                activeSuggestionIndex = 0;
            } else {
                activeSuggestionIndex = nextIndex;
            }

            setActiveSymbolSuggestion(activeSuggestionIndex);
        }

        function selectSymbolSuggestion(item) {
            if (!stockSymbolInput || !item) {
                return;
            }
            stockSymbolInput.value = String(item.ticker || '').toUpperCase();
            hideSymbolSuggestions();
            stockSymbolInput.focus();
        }

        function handleSymbolInput(event) {
            if (!event || !stockSymbolInput) {
                return;
            }
            const suggestions = filterSymbolSuggestions(event.target.value);
            renderSymbolSuggestions(suggestions);
        }

        function handleSymbolKeydown(event) {
            if (!symbolSuggestionsEl || symbolSuggestionsEl.classList.contains('hidden')) {
                return;
            }

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                moveSymbolSuggestionFocus(1);
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                moveSymbolSuggestionFocus(-1);
            } else if (event.key === 'Enter') {
                if (activeSuggestionIndex >= 0 && currentSymbolSuggestions[activeSuggestionIndex]) {
                    event.preventDefault();
                    selectSymbolSuggestion(currentSymbolSuggestions[activeSuggestionIndex]);
                }
            } else if (event.key === 'Escape') {
                hideSymbolSuggestions();
            }
        }

        if (stockSymbolInput) {
            stockSymbolInput.addEventListener('input', handleSymbolInput);
            stockSymbolInput.addEventListener('focus', () => handleSymbolInput({ target: stockSymbolInput }));
            stockSymbolInput.addEventListener('keydown', handleSymbolKeydown);
            stockSymbolInput.addEventListener('blur', () => {
                setTimeout(hideSymbolSuggestions, 120);
            });
        }

        if (symbolSuggestionsEl) {
            symbolSuggestionsEl.addEventListener('mousedown', (event) => {
                const option = event.target.closest('.symbol-suggestion');
                if (!option) {
                    return;
                }
                event.preventDefault();
                const index = Number(option.getAttribute('data-index'));
                if (Number.isNaN(index)) {
                    return;
                }
                const item = currentSymbolSuggestions[index];
                if (item) {
                    selectSymbolSuggestion(item);
                }
            });
        }

        if (marketSelect) {
            marketSelect.addEventListener('change', (event) => {
                currentMarket = event.target.value || 'equity';
                hideSymbolSuggestions();
                updateMarketUI();
            });
        }

        updateMarketUI();

        includePrincipalRawInput.disabled = !usePrincipalAgentInput.checked;

        usePrincipalAgentInput.addEventListener('change', (event) => {
            const enabled = event.target.checked;
            includePrincipalRawInput.disabled = !enabled;
            if (!enabled) {
                includePrincipalRawInput.checked = false;
            }
        });
        
        document.getElementById('tradingForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const stockSymbol = stockSymbolInput ? stockSymbolInput.value.trim().toUpperCase() : '';
            const useAiAnalysis = useAiAnalysisInput ? useAiAnalysisInput.checked : false;
            const usePrincipalAgent = usePrincipalAgentInput.checked;
            const includePrincipalRaw = includePrincipalRawInput.checked;
            const resultsPanel = document.getElementById('resultsPanel');
            const resultTabs = document.getElementById('resultTabs');
            const technicalTab = document.getElementById('technicalTab');
            const priceActionContent = document.getElementById('priceActionContent');
            const aiContent = document.getElementById('aiContent');
            const principalPlanContent = document.getElementById('principalPlanContent');
            if (symbolSuggestionsEl) {
                hideSymbolSuggestions();
            }
            if (symbolMessageEl) {
                symbolMessageEl.classList.add('hidden');
                symbolMessageEl.innerHTML = '';
            }
            
            if (!stockSymbol) {
                alert('Please enter a symbol to analyze');
                return;
            }

            const marketValue = currentMarket;
            
            // Show loading state
            analyzeBtn.disabled = true;
            const activeTasks = [];
            activeTasks.push('Price Action');
            if (useAiAnalysis) activeTasks.push('AI');
            if (usePrincipalAgent) activeTasks.push('Principal');
            analyzeBtn.textContent = activeTasks.length
                ? `Analyzing (${activeTasks.join(' + ')})...`
                : 'Analyzing...';
            resultsPanel.style.display = 'block';
            resultTabs.classList.add('hidden');
            principalTab.style.display = 'none';
            priceActionTab.style.display = 'none';
            principalTab.classList.remove('active');
            priceActionTab.classList.remove('active');
            technicalTab.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById('technicalContent').classList.add('active');
            
            document.getElementById('technicalContent').innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Analyzing ${stockSymbol}... This may take a few moments.</p>
                </div>
            `;
            aiContent.innerHTML = '';
            principalPlanContent.innerHTML = '';
            priceActionContent.innerHTML = '';
            
            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        stock_symbol: stockSymbol,
                        market: marketValue,
                        use_ai_analysis: useAiAnalysis,
                        use_principal_agent: usePrincipalAgent,
                        include_principal_raw_results: includePrincipalRaw
                    })
                });
                let data;
                try {
                    data = await response.json();
                } catch (parseError) {
                    data = { success: false, error: 'Unexpected server response. Please try again.' };
                }

                if (data && typeof data === 'object' && !('status' in data)) {
                    data.status = response.status;
                }

                if (response.ok && data.success) {
                    if (data.market && typeof data.market === 'string' && data.market !== currentMarket) {
                        currentMarket = data.market;
                        if (marketSelect) {
                            marketSelect.value = data.market;
                        }
                        updateMarketUI();
                    }
                    currentResults = data;
                    displayResults(data, stockSymbol);
                    let extraTabs = 0;
                    displayPriceAction(data.price_action);
                    priceActionTab.style.display = 'block';
                    extraTabs += 1;
                    let principalTabHasData = false;
                    // Show initial AI analysis if present (legacy synchronous responses)
                    if (useAiAnalysis && Object.prototype.hasOwnProperty.call(data, 'ai_analysis') && data.ai_analysis) {
                        principalTabHasData = displayAiAnalysis(data.ai_analysis) || principalTabHasData;
                    }
                    if (usePrincipalAgent && Object.prototype.hasOwnProperty.call(data, 'principal_plan')) {
                        principalTabHasData = displayPrincipalPlan(data.principal_plan) || principalTabHasData;
                    }
                    if (principalTabHasData) {
                        principalTab.style.display = 'block';
                        extraTabs += 1;
                    } else {
                        aiContent.innerHTML = '';
                        principalPlanContent.innerHTML = '';
                    }
                    if (extraTabs > 0) {
                        resultTabs.classList.remove('hidden');
                    }

                    if (symbolMessageEl && data.symbol_message) {
                        symbolMessageEl.innerHTML = `<div class="result-content">${escapeHtml(data.symbol_message)}</div>`;
                        symbolMessageEl.classList.remove('hidden');
                    }

                    // If ai_job_id is present, start polling for async analysis
                    if (data.ai_job_id) {
                        pollAiAnalysis({
                            jobId: data.ai_job_id,
                            includeAi: useAiAnalysis,
                            includePrincipal: usePrincipalAgent,
                            aiContent,
                            principalTab,
                            principalPlanContent,
                            resultTabs,
                        });
                    }
                } else {
                    displayError(data);
                    if (symbolMessageEl && data && data.code === 'unknown_symbol') {
                        const suggestionText = data.error || 'Please choose a supported ticker.';
                        symbolMessageEl.innerHTML = `<div class="result-content">${escapeHtml(suggestionText)}</div>`;
                        symbolMessageEl.classList.remove('hidden');
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                displayError({ error: 'Network error occurred. Please try again.' });
            } finally {
                analyzeBtn.disabled = false;
                updateMarketUI();
            }
        });

        // Code Generated by Sidekick is for learning and experimentation purposes only.
        function safeToFixed(val, digits=2, fallback='N/A') {
        return (val !== null && val !== undefined) ? Number(val).toFixed(digits) : fallback;
        }
        function displayResults(data, symbol) {
            const technicalContent = document.getElementById('technicalContent');
            const result = data.result;
            const symbolData = result && result[symbol] ? result[symbol] : null;
            if (!symbolData) {
                technicalContent.innerHTML = `
                    <div class="result-item error">
                        <div class="result-title">Result Not Found</div>
                        <div class="result-content">No analysis data for ${symbol}.</div>
                    </div>
                ` + LEGAL_NOTE_HTML;
                return;
            }
            // Consensus summary table (no inline style)
            const cons = symbolData.consensus || {};
            const latestPriceCell = `${escapeHtml(formatPrice(symbolData.latest_price))}`;

            const reasoningItems = Array.isArray(cons.reasoning)
                ? cons.reasoning.map(item => `<li>${escapeHtml(String(item))}</li>`).join('')
                : '<li>No additional context.</li>';

            const strengthText = (() => {
                const strengthValue = Number(cons.strength);
                if (Number.isFinite(strengthValue)) {
                    return `${strengthValue.toFixed(2)}%`;
                }
                return 'N/A';
            })();

            let consensusHtml = `<table>
                <tr>
                    <th colspan="2">Consensus Summary</th>
                </tr>
                <tr>
                    <td>Symbol</td>
                    <td><strong>${escapeHtml(symbol)}</strong></td>
                </tr>
                <tr>
                    <td>Current Price</td>
                    <td>${latestPriceCell}</td>
                </tr>
                <tr>
                    <td>Overall Recommendation</td>
                    <td><strong>${escapeHtml(cons.overall_recommendation || 'N/A')}</strong></td>
                </tr>
                <tr>
                    <td>Confidence</td>
                    <td>${escapeHtml(cons.confidence || 'N/A')}</td>
                </tr>
                <tr>
                    <td>Strength</td>
                    <td>${escapeHtml(strengthText)}</td>
                </tr>
                <tr>
                    <td>Buy Signals</td>
                    <td>${escapeHtml(String(cons.buy_signals ?? 'N/A'))}</td>
                </tr>
                <tr>
                    <td>Sell Signals</td>
                    <td>${escapeHtml(String(cons.sell_signals ?? 'N/A'))}</td>
                </tr>
                <tr>
                    <td>Hold Signals</td>
                    <td>${escapeHtml(String(cons.hold_signals ?? 'N/A'))}</td>
                </tr>
                <tr>
                    <td>Reasoning</td>
                    <td>
                    <ul>
                    ${reasoningItems}
                    </ul>
                    </td>
                </tr>
            </table>`;

            // Decisions by timeframe (no inline style)
            const decisions = symbolData.decisions || {};
            let decisionHtml = `<table class="decisions-table">
                <thead>
                <tr>
                    <th>Timeframe</th>
                    <th>Sig.</th>
                    <th>Conf.</th>
                    <th>Strength</th>
                    <th>Entry</th>
                    <th>Stop</th>
                    <th>Target</th>
                    <th>R/R</th>
                    <th>Reasoning</th>
                </tr>
                </thead>
                <tbody>
            `;
            for (const [tf, d] of Object.entries(decisions)) {
                decisionHtml += `
                <tr>
                    <td data-label="Timeframe">${escapeHtml(tf)}</td>
                    <td data-label="Sig." style="color:${d.recommendation === 'BUY' ? '#27ae60' : d.recommendation === 'SELL' ? '#e74c3c' : '#333'};font-weight:bold">${d.recommendation}</td>
                    <td data-label="Conf.">${d.confidence}</td>
                    <td data-label="Strength">${safeToFixed(d.strength)}%</td>
                    <td data-label="Entry">$${safeToFixed(d.entry_price)}</td>
                    <td data-label="Stop">$${safeToFixed(d.stop_loss)}</td>
                    <td data-label="Target">$${safeToFixed(d.take_profit)}</td>
                    <td data-label="R/R">${safeToFixed(d.risk_reward_ratio)}</td>
                    <td data-label="Reasoning">
                    <ul>
                    ${d.reasoning.map(r => `<li>${r}</li>`).join('')}
                    </ul>
                    </td>
                </tr>
                `;
            }
            decisionHtml += "</tbody></table>";
            const runsRemaining = typeof data.runs_remaining === 'number' ? data.runs_remaining : null;
            const runsMeta = runsRemaining !== null
                ? `<div class="result-meta"><div>Runs remaining: <strong>${escapeHtml(String(runsRemaining))}</strong></div></div>`
                : '';
            technicalContent.innerHTML = `
                <div class="result-item success">
                    <div class="result-title">Technical Analysis Table for ${symbol}</div>
                    <div class="result-content">
                        ${consensusHtml}
                        ${decisionHtml}
                    </div>
                    ${runsMeta}
                </div>
            ` + LEGAL_NOTE_HTML;
        }
        function displayAiAnalysis(aiAnalysis) {
            const aiContent = document.getElementById('aiContent');
            if (!aiContent) {
                return false;
            }
            if (!aiAnalysis) {
                aiContent.innerHTML = `<div class="result-item">
                    <div class="result-title">AI Analysis</div>
                    <div class="result-content">AI analysis was not requested or failed.</div>
                </div>${LEGAL_NOTE_HTML}`;
                return true;
            }
            if (!aiAnalysis.success) {
                aiContent.innerHTML = `<div class="result-item error">
                    <div class="result-title">AI Analysis Failed</div>
                    <div class="result-content">${aiAnalysis.error}</div>
                </div>${LEGAL_NOTE_HTML}`;
                return true;
            }
            const analysis = aiAnalysis.analysis;
            const aiPriceSummary = typeof aiAnalysis.latest_price !== 'undefined'
                ? `<div class="result-meta">Current Price: <strong>${escapeHtml(formatPrice(aiAnalysis.latest_price))}</strong></div>`
                : '';
            let html = `<div class="result-item success ai-analysis">
                <div class="result-title">AI Investment strategy</div>
                <div class="result-content">AI analysis completed successfully using ${escapeHtml(String(aiAnalysis.tokens_used || 'N/A'))} tokens.${aiPriceSummary}</div>
            </div>`;
            if (analysis) {
                if (analysis.market_position) {
                    html += `<div class="ai-section">
                        <div class="ai-section-title">Current Market Position</div>
                        <div class="result-content">${analysis.market_position}</div>
                    </div>`;
                }
                if (analysis.short_term_strategy) {
                    html += `<div class="ai-section">
                        <div class="ai-section-title">Short-Term Strategy (1-30 days)</div>
                        <div class="result-content">${analysis.short_term_strategy}</div>
                    </div>`;
                }
                if (analysis.long_term_strategy) {
                    html += `<div class="ai-section">
                        <div class="ai-section-title">Long-Term Strategy (3-12 months)</div>
                        <div class="result-content">${analysis.long_term_strategy}</div>
                    </div>`;
                }
                if (analysis.risk_assessment) {
                    html += `<div class="ai-section">
                        <div class="ai-section-title">Risk Assessment</div>
                        <div class="result-content">${analysis.risk_assessment}</div>
                    </div>`;
                }
                if (analysis.action_items) {
                    html += `<div class="ai-section">
                        <div class="ai-section-title">Action Items</div>
                        <div class="result-content">${analysis.action_items}</div>
                    </div>`;
                }
                if (analysis.summary) {
                    html += `<div class="ai-section">
                        <div class="ai-section-title">Summary</div>
                        <div class="result-content">${analysis.summary}</div>
                    </div>`;
                }
            }
            if (!analysis && aiAnalysis.raw_response) {
                html += `<div class="result-item ai-analysis">
                    <div class="result-title">AI Investment strategy</div>
                    <div class="result-content">${aiAnalysis.raw_response}</div>
                </div>`;
            }
            html += LEGAL_NOTE_HTML;
            aiContent.innerHTML = html;
            return true;
        }
        function displayPrincipalPlan(principalPlan) {
            const container = document.getElementById('principalPlanContent') || document.getElementById('principalContent');
            if (!container) {
                return false;
            }

            if (!principalPlan) {
                container.innerHTML = `<div class="result-item">
                    <div class="result-title">Principal Plan</div>
                    <div class="result-content">Principal plan was not requested.</div>
                </div>${LEGAL_NOTE_HTML}`;
                return true;
            }

            if (!principalPlan.success) {
                const errorMessage = principalPlan.error || 'Principal agent failed to generate a plan.';
                container.innerHTML = `<div class="result-item error">
                    <div class="result-title">Principal Plan Failed</div>
                    <div class="result-content">${errorMessage}</div>
                </div>${LEGAL_NOTE_HTML}`;
                return true;
            }

            const plan = principalPlan.data;
            if (!plan) {
                container.innerHTML = `<div class="result-item">
                    <div class="result-title">Principal Plan</div>
                    <div class="result-content">Plan data unavailable.</div>
                </div>${LEGAL_NOTE_HTML}`;
                return true;
            }

            const strategies = plan.strategies || {};
            const strategyOrder = [
                { key: 'day_trading', label: 'Day Trading' },
                { key: 'swing_trading', label: 'Swing Trading' },
                { key: 'longterm_trading', label: 'Long-Term Trading' },
            ];

            let strategyHtml = '';
            strategyOrder.forEach(({ key, label }) => {
                const strategy = strategies[key];
                if (!strategy) {
                    return;
                }

                const summaryHtml = formatPlanField('Summary', strategy.summary || 'No summary provided.');
                const keyLevelsHtml = formatPlanField('Key Levels', strategy.key_levels);
                const nextActionsHtml = formatPlanField('Next Actions', strategy.next_actions);
                const fieldsHtml = [summaryHtml, keyLevelsHtml, nextActionsHtml].filter(Boolean).join('');

                if (!fieldsHtml) {
                    return;
                }

                strategyHtml += `<div class="ai-section plan-section">
                    <div class="ai-section-title">${label}</div>
                    <div class="plan-section__content">${fieldsHtml}</div>
                </div>`;
            });

            const usage = plan.usage;
            const generatedAt = formatDateTime(plan.generated_at);

            const summaryCells = [
                { label: 'Symbol', value: plan.symbol || 'N/A' },
            ];

            if (typeof plan.latest_price !== 'undefined') {
                summaryCells.push({
                    label: 'Current Price',
                    value: formatPrice(plan.latest_price),
                });
            }

            summaryCells.push({ label: 'Generated', value: generatedAt });

            if (usage) {
                summaryCells.push({ label: 'Tokens Used', value: usage.total_tokens ?? 'N/A' });
            }

            const summaryGridHtml = summaryCells
                .map(({ label, value }) => `<div class="plan-summary__cell">
                        <span class="plan-summary__label">${escapeHtml(label)}</span>
                        <span class="plan-summary__value">${escapeHtml(String(value ?? 'N/A'))}</span>
                    </div>`)
                .join('');

            const expertDiagnosticsHtml = renderExpertReports(plan.trading_agent_outputs);
            const rawSection = !expertDiagnosticsHtml && plan.trading_agent_outputs
                ? `<details class="plan-raw">
                        <summary>Expert Diagnostics</summary>
                        <pre>${escapeHtml(JSON.stringify(plan.trading_agent_outputs, null, 2))}</pre>
                   </details>`
                : '';

            const contextHtml = plan.context ? renderPlanContext(plan.context) : '';

            container.innerHTML = `
                <div class="result-item success ai-analysis plan-summary">
                    <div class="result-title">Multi AI Agent Trading Strategy</div>
                    <div class="plan-summary__grid">
                        ${summaryGridHtml}
                    </div>
                </div>
                ${strategyHtml || '<div class="result-item"><div class="result-content">No strategy breakdown available.</div></div>'}
                ${contextHtml}
                ${expertDiagnosticsHtml || rawSection}
                ${LEGAL_NOTE_HTML}
            `;
            return true;
        }

        function displayPriceAction(priceAction) {
            const container = document.getElementById('priceActionContent');
            if (!container) {
                return;
            }
            if (!priceAction) {
                container.innerHTML = `<div class="result-item">
                    <div class="result-title">Price Action</div>
                    <div class="result-content">No price action data available.</div>
                </div>${LEGAL_NOTE_HTML}`;
                return;
            }

            const headerMessage = priceAction.success
                ? 'Price action insights generated.'
                : (priceAction.error || 'Price action analysis failed.');

            let currentPriceHtml = '';
            if (typeof priceAction.latest_price !== 'undefined') {
                currentPriceHtml = `<div><strong>Current Price:</strong> ${escapeHtml(formatPrice(priceAction.latest_price))}</div>`;
            }

            let html = `
                <div class="result-item ${priceAction.success ? 'success' : 'error'}">
                    <div class="result-title">Price Action Summary</div>
                    <div class="result-content price-action-summary">
                        <div><strong>Symbol:</strong> ${escapeHtml(priceAction.symbol || 'N/A')}</div>
                        <div><strong>Generated:</strong> ${escapeHtml(formatDateTime(priceAction.generated_at))}</div>
                        ${currentPriceHtml}
                        <div>${escapeHtml(headerMessage)}</div>
                    </div>
                </div>
            `;

            const overview = priceAction.overview || {};
            const keyLevels = Array.isArray(overview.key_levels) ? overview.key_levels : [];
            const recentPatterns = Array.isArray(overview.recent_patterns) ? overview.recent_patterns : [];

            if (overview.trend_alignment || keyLevels.length || recentPatterns.length) {
                const levelsHtml = keyLevels.length
                    ? `<ul>${keyLevels.map(level => {
                        const tfLabel = formatTimeframeLabel(level.timeframe);
                        const tf = tfLabel ? escapeHtml(tfLabel) : 'Timeframe';
                        const type = escapeHtml(capitalize(level.type || 'level'));
                        const price = escapeHtml(formatPrice(level.price));
                        const distance = escapeHtml(formatPercent(level.distance_pct));
                        return `<li>${tf} · ${type} at ${price} (${distance})</li>`;
                    }).join('')}</ul>`
                    : '<div class="price-action-note">No shared support or resistance levels detected.</div>';

                const patternsHtml = recentPatterns.length
                    ? `<ul>${recentPatterns.map(pattern => {
                        const label = escapeHtml(pattern.pattern || 'Pattern');
                        const tfLabel = formatTimeframeLabel(pattern.timeframe);
                        const tf = tfLabel ? escapeHtml(tfLabel) : '';
                        const confidence = formatNumber(pattern.confidence, 2);
                        const confidenceText = confidence === 'N/A' ? '' : ` (score ${confidence})`;
                        return `<li>${label}${tf ? ` · ${tf}` : ''}${escapeHtml(confidenceText)}</li>`;
                    }).join('')}</ul>`
                    : '<div class="price-action-note">No notable candlestick patterns across timeframes.</div>';

                html += `
                    <div class="result-item info">
                        <div class="result-title">Multi-Timeframe Alignment</div>
                        <div class="result-content price-action-overview">
                            <p><strong>Trend alignment:</strong> ${escapeHtml(overview.trend_alignment || 'Unknown')}</p>
                            <div class="price-action-overview__levels">
                                <strong>Key levels:</strong>
                                ${levelsHtml}
                            </div>
                            <div class="price-action-overview__patterns">
                                <strong>Recent patterns:</strong>
                                ${patternsHtml}
                            </div>
                        </div>
                    </div>
                `;
            }

            const perTimeframe = priceAction.per_timeframe && typeof priceAction.per_timeframe === 'object'
                ? Object.entries(priceAction.per_timeframe)
                : [];

            if (perTimeframe.length) {
                html += perTimeframe.map(([timeframe, details]) => renderPriceActionCard(timeframe, details)).join('');
            } else {
                html += `<div class="result-item">
                    <div class="result-content">No timeframe-specific price action details available.</div>
                </div>`;
            }

            const pipelineErrors = Array.isArray(priceAction.errors) ? priceAction.errors.filter(Boolean) : [];
            if (pipelineErrors.length) {
                html += `<div class="result-item info">
                    <div class="result-title">Data Warnings</div>
                    <div class="result-content"><ul>${pipelineErrors.map(msg => `<li>${escapeHtml(msg)}</li>`).join('')}</ul></div>
                </div>`;
            }

            html += LEGAL_NOTE_HTML;
            container.innerHTML = html;
        }

        function renderPriceActionCard(timeframe, details) {
            const info = details || {};
            const price = info.price || {};
            const trend = info.trend || {};
            const structure = info.structure || {};
            const levels = info.levels || {};
            const candlestick = info.candlestick || {};

            const supportsHtml = renderPriceActionLevels(levels.supports, 'Supports');
            const resistancesHtml = renderPriceActionLevels(levels.resistances, 'Resistances');
            const recentPivots = levels.recent_pivots || {};
            const pivotHighs = Array.isArray(recentPivots.highs) ? recentPivots.highs.length : 0;
            const pivotLows = Array.isArray(recentPivots.lows) ? recentPivots.lows.length : 0;
            const pivotSummary = pivotHighs || pivotLows
                ? `<div class="price-action-note"><strong>Recent pivots:</strong> ${escapeHtml(`${pivotHighs} highs · ${pivotLows} lows`)}</div>`
                : '';

            const slopePct = formatNumber(trend.slope_pct, 2);
            const slopePctDisplay = slopePct === 'N/A' ? 'N/A' : `${slopePct}%`;

            const priceItems = [
                `<li>Open: ${escapeHtml(formatPrice(price.open))}</li>`,
                `<li>High: ${escapeHtml(formatPrice(price.high))}</li>`,
                `<li>Low: ${escapeHtml(formatPrice(price.low))}</li>`,
                `<li>Close: ${escapeHtml(formatPrice(price.close))}</li>`,
                `<li>Change: ${escapeHtml(formatPercent(price.close_change_pct))}</li>`,
                `<li>Volume: ${escapeHtml(formatInteger(price.volume))}</li>`,
                `<li>Timestamp: ${escapeHtml(formatDateTime(price.timestamp))}</li>`,
            ].join('');

            const trendItems = [
                `<li>Direction: ${escapeHtml(capitalize(trend.direction || 'unknown'))}</li>`,
                `<li>Strength: ${escapeHtml(capitalize(trend.strength || 'unknown'))}</li>`,
                `<li>Slope: ${escapeHtml(formatNumber(trend.slope, 6))}</li>`,
                `<li>Slope %: ${escapeHtml(slopePctDisplay)}</li>`,
                `<li>R²: ${escapeHtml(formatNumber(trend.r_squared, 3))}</li>`,
                `<li>Window: ${escapeHtml(formatInteger(trend.window))}</li>`,
            ].join('');

            const structureItems = [
                `<li>Bias: ${escapeHtml(capitalize(structure.bias || 'mixed'))}</li>`,
                `<li>Higher highs: ${escapeHtml(formatBoolean(structure.higher_highs))}</li>`,
                `<li>Higher lows: ${escapeHtml(formatBoolean(structure.higher_lows))}</li>`,
                `<li>Lower highs: ${escapeHtml(formatBoolean(structure.lower_highs))}</li>`,
                `<li>Lower lows: ${escapeHtml(formatBoolean(structure.lower_lows))}</li>`,
                `<li>Range state: ${escapeHtml(capitalize(structure.range_state || 'unknown'))}</li>`,
                `<li>Range ratio: ${escapeHtml(formatNumber(structure.range_ratio, 2))}</li>`,
            ].join('');

            const signalsHtml = renderPriceActionSignals(candlestick.signals);
            const latestCandle = candlestick.latest_candle || {};
            const latestStamp = latestCandle.timestamp
                ? `<div class="price-action-note">Pattern candle: ${escapeHtml(formatDateTime(latestCandle.timestamp))}</div>`
                : '';

            const tfText = formatTimeframeLabel(timeframe) || 'Timeframe';
            const tfLabel = escapeHtml(tfText);

            return `<div class="result-item">
                <div class="result-title">${tfLabel} Price Action</div>
                <div class="result-content price-action-card">
                    <div class="price-action-section">
                        <strong>Last Candle</strong>
                        <ul>${priceItems}</ul>
                    </div>
                    <div class="price-action-section">
                        <strong>Trend Context</strong>
                        <ul>${trendItems}</ul>
                    </div>
                    <div class="price-action-section">
                        <strong>Market Structure</strong>
                        <ul>${structureItems}</ul>
                        ${pivotSummary}
                    </div>
                    <div class="price-action-section">
                        <strong>Support &amp; Resistance</strong>
                        ${supportsHtml}
                        ${resistancesHtml}
                    </div>
                    <div class="price-action-section">
                        <strong>Candlestick Signals</strong>
                        ${signalsHtml}
                        ${latestStamp}
                    </div>
                </div>
            </div>`;
        }

        function renderPriceActionLevels(levels, label) {
            if (!Array.isArray(levels) || levels.length === 0) {
                return `<p><strong>${escapeHtml(label)}:</strong> N/A</p>`;
            }
            const items = levels.map(level => {
                const price = formatPrice(level.price);
                const distance = formatPercent(level.distance_pct);
                const tested = formatDateTime(level.tested_at);
                return `<li>${escapeHtml(price)} · distance ${escapeHtml(distance)} · tested ${escapeHtml(tested)}</li>`;
            }).join('');
            return `<div><strong>${escapeHtml(label)}:</strong><ul>${items}</ul></div>`;
        }

        function renderPriceActionSignals(signals) {
            if (!Array.isArray(signals) || signals.length === 0) {
                return '<p>No strong candlestick patterns.</p>';
            }
            const items = signals.map(signal => {
                const name = capitalize(signal.name || 'Pattern');
                const confidence = formatNumber(signal.confidence, 2);
                const confidenceText = confidence === 'N/A' ? '' : ` (${confidence})`;
                return `<li>${escapeHtml(name)}${escapeHtml(confidenceText)}</li>`;
            }).join('');
            return `<ul>${items}</ul>`;
        }

        function formatDateTime(value) {
            if (!value) {
                return 'N/A';
            }
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
                return typeof value === 'string' ? value : 'N/A';
            }
            return date.toLocaleString();
        }

        function formatNumber(value, digits = 2) {
            const num = Number(value);
            if (!Number.isFinite(num)) {
                return 'N/A';
            }
            return num.toFixed(digits);
        }

        function formatInteger(value) {
            const num = Number(value);
            if (!Number.isFinite(num)) {
                return 'N/A';
            }
            return Math.round(num).toLocaleString();
        }

        function formatPrice(value) {
            const formatted = formatNumber(value, 2);
            return formatted === 'N/A' ? 'N/A' : `$${formatted}`;
        }

        function formatPercent(value, digits = 2) {
            const num = Number(value);
            if (!Number.isFinite(num)) {
                return 'N/A';
            }
            return `${num.toFixed(digits)}%`;
        }

        function formatBoolean(value) {
            if (value === true) return 'Yes';
            if (value === false) return 'No';
            return 'Unknown';
        }

        function capitalize(value) {
            if (value === null || value === undefined) {
                return 'Unknown';
            }
            const str = String(value);
            if (!str.length) {
                return 'Unknown';
            }
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        function formatTimeframeLabel(value) {
            if (value === null || value === undefined) {
                return '';
            }
            const str = String(value).trim();
            if (!str) {
                return '';
            }
            const match = str.match(/^(\d+)([a-zA-Z]+)$/);
            if (!match) {
                return str.toUpperCase();
            }

            const quantity = Number(match[1]);
            const unitRaw = match[2].toLowerCase();
            const lookup = {
                m: 'Minute',
                min: 'Minute',
                h: 'Hour',
                hr: 'Hour',
                d: 'Day',
                day: 'Day',
                wk: 'Week',
                w: 'Week',
                mo: 'Month',
                mon: 'Month'
            };
            const normalized = lookup[unitRaw]
                || lookup[unitRaw.slice(0, 2)]
                || lookup[unitRaw.charAt(0)]
                || unitRaw.toUpperCase();
            const plural = quantity !== 1 && !normalized.endsWith('s');
            const unitLabel = plural ? `${normalized}s` : normalized;
            return `${quantity} ${unitLabel}`;
        }

        function expandTimeframeTokens(text) {
            if (typeof text !== 'string') {
                return text;
            }
            const lookup = {
                m: 'minute',
                min: 'minute',
                h: 'hour',
                hr: 'hour',
                d: 'day',
                day: 'day',
                wk: 'week',
                w: 'week',
                mo: 'month',
                mon: 'month'
            };
            return text.replace(/(\d+)\s*(m|min|h|hr|d|day|wk|w|mo|mon)\b/gi, (match, qty, unitRaw) => {
                const unit = lookup[unitRaw.toLowerCase()];
                if (!unit) {
                    return match;
                }
                const quantity = Number(qty);
                const plural = Number.isFinite(quantity) && quantity !== 1;
                const unitLabel = plural ? `${unit}s` : unit;
                return `${quantity} ${unitLabel}`;
            });
        }

        function contextSuggestsPrice(contextKey) {
            if (!contextKey) {
                return false;
            }
            const key = String(contextKey).toLowerCase();
            const keywords = ['price', 'entry', 'exit', 'target', 'level', 'support', 'resistance', 'stop', 'take', 'trigger'];
            return keywords.some(token => key.includes(token));
        }

        function formatNumericValue(value, contextKey) {
            if (typeof value === 'boolean') {
                return value ? 'Yes' : 'No';
            }
            if (!Number.isFinite(value)) {
                return String(value);
            }
            if (contextSuggestsPrice(contextKey)) {
                return Number(value).toFixed(2);
            }
            if (!Number.isInteger(value)) {
                return Number(value).toFixed(2);
            }
            return String(value);
        }

        function formatPriceTokens(text, contextKey) {
            if (typeof text !== 'string' || !text.trim()) {
                return text;
            }
            let working = text;
            if (contextSuggestsPrice(contextKey)) {
                const numericOnly = working.match(/^\$?-?\d+(?:\.\d+)?$/);
                if (numericOnly) {
                    const numeric = Number(numericOnly[0].replace('$', ''));
                    if (Number.isFinite(numeric)) {
                        return (working.startsWith('$') ? '$' : '') + numeric.toFixed(2);
                    }
                }
            }
            working = working.replace(/\$(\s*-?\d+(?:\.\d+)?)/g, (_, amount) => {
                const numeric = Number(amount.replace(/\s+/g, ''));
                if (!Number.isFinite(numeric)) {
                    return `$${amount.trim()}`;
                }
                return `$${numeric.toFixed(2)}`;
            });
            return working;
        }

        function formatPlanField(label, value) {
            const rendered = renderPlanValue(value, label);
            if (!rendered) return '';
            return `<div class="plan-field"><strong>${escapeHtml(label)}:</strong> ${rendered}</div>`;
        }

        function renderPlanValue(value, contextKey = '') {
            if (value === null || value === undefined) {
                return '';
            }
            if (typeof value === 'string') {
                const expanded = expandTimeframeTokens(value);
                const formatted = formatPriceTokens(expanded, contextKey);
                return `<span>${escapeHtml(formatted)}</span>`;
            }
            if (typeof value === 'number' || typeof value === 'boolean') {
                const formatted = formatNumericValue(value, contextKey);
                return `<span>${escapeHtml(formatted)}</span>`;
            }
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    return '';
                }
                return `<ul class="plan-list">${value.map(item => `<li>${renderPlanValue(item, contextKey) || ''}</li>`).join('')}</ul>`;
            }
            if (typeof value === 'object') {
                const entries = Object.entries(value);
                if (entries.length === 0) {
                    return '';
                }
                return `<ul class="plan-list">${entries.map(([key, val]) => `<li><strong>${escapeHtml(humanizeKey(key))}:</strong> ${renderPlanValue(val, key) || ''}</li>`).join('')}</ul>`;
            }
            return `<span>${escapeHtml(String(value))}</span>`;
        }

        function renderPlanContext(context) {
            const rendered = renderPlanValue(context, 'context');
            if (!rendered) {
                return '';
            }
            return `<div class="result-item info plan-context">
                <div class="result-title">Portfolio Context</div>
                <div class="result-content">${rendered}</div>
            </div>`;
        }

        function renderExpertReports(expertOutputs) {
            if (!expertOutputs || typeof expertOutputs !== 'object') {
                return '';
            }

            const cards = Object.entries(expertOutputs)
                .map(([key, data]) => {
                    if (!data || typeof data !== 'object') {
                        return '';
                    }

                    const isSuccess = data.success !== false;
                    const statusClass = isSuccess ? 'success' : 'error';
                    const statusLabel = isSuccess ? 'Ready' : 'Issue';
                    const heading = typeof data.agent === 'string' && data.agent.trim()
                        ? data.agent.trim()
                        : humanizeKey(key);

                    const metaItems = [];
                    if (data.symbol) {
                        metaItems.push(`Symbol ${String(data.symbol).toUpperCase()}`);
                    }
                    const usage = data.model_usage;
                    const tokenCount = usage && (usage.total_tokens ?? usage.output_tokens ?? usage.input_tokens);
                    if (tokenCount !== undefined) {
                        metaItems.push(`Tokens ${tokenCount}`);
                    }
                    const timestamp = data.generated_at || data.collected_at || data.timestamp;
                    if (timestamp) {
                        metaItems.push(`Generated ${formatDateTime(timestamp)}`);
                    }
                    const metaHtml = metaItems.length
                        ? `<div class="expert-card__meta">${metaItems
                            .map(item => `<span class="expert-card__meta-item">${escapeHtml(item)}</span>`)
                            .join('')}</div>`
                        : '';

                    const agentOutput = data.agent_output ?? data.agent_result;
                    const renderedOutput = renderExpertOutputSections(agentOutput);
                    const fallbackText = !renderedOutput && data.raw_text
                        ? `<pre class="expert-card__note">${escapeHtml(data.raw_text)}</pre>`
                        : '';
                    const errorHtml = !isSuccess && data.error
                        ? `<div class="expert-card__message expert-card__message--error">${escapeHtml(data.error)}</div>`
                        : '';

                    const content = [metaHtml, errorHtml, renderedOutput || fallbackText]
                        .filter(Boolean)
                        .join('');

                    if (!content) {
                        return '';
                    }

                    return `<details class="expert-card">
                        <summary class="expert-card__summary">
                            <span class="expert-card__title">${escapeHtml(heading)}</span>
                            <span class="expert-card__status expert-card__status--${statusClass}">${escapeHtml(statusLabel)}</span>
                        </summary>
                        <div class="expert-card__content">
                            ${content}
                        </div>
                    </details>`;
                })
                .filter(Boolean)
                .join('');

            if (!cards) {
                return '';
            }

            return `<div class="ai-section plan-section">
                <div class="ai-section-title">Expert Diagnostics</div>
                <div class="plan-section__content expert-report">
                    ${cards}
                </div>
            </div>`;
        }

        function humanizeKey(value) {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value)
                .replace(/[_\-]+/g, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .replace(/\b\w/g, char => char.toUpperCase());
        }

        function renderExpertOutputSections(output) {
            if (output === null || output === undefined) {
                return '';
            }
            if (Array.isArray(output)) {
                return renderPlanValue(output);
            }
            if (typeof output !== 'object') {
                return renderPlanValue(output);
            }

            const entries = Object.entries(output);
            if (entries.length === 0) {
                return '';
            }

            const sections = entries
                .map(([field, value]) => {
                    const renderedValue = renderPlanValue(value, field);
                    if (!renderedValue) {
                        return '';
                    }
                    return `<div class="expert-field">
                        <div class="expert-field__label">${escapeHtml(humanizeKey(field))}</div>
                        <div class="expert-field__value">${renderedValue}</div>
                    </div>`;
                })
                .filter(Boolean)
                .join('');

            if (sections) {
                return sections;
            }

            return renderPlanValue(output, 'expert_output');
        }

        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return String(unsafe)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        function displayError(payload) {
            const technicalContent = document.getElementById('technicalContent');
            if (symbolMessageEl) {
                symbolMessageEl.classList.add('hidden');
                symbolMessageEl.innerHTML = '';
            }
            const detail = (typeof payload === 'string' || payload instanceof String)
                ? { error: payload }
                : (payload || {});
            const errorText = detail.error || detail.detail || detail.message || 'Analysis failed.';
            const runsRemaining = typeof detail.runs_remaining === 'number' ? detail.runs_remaining : null;
            const renewsAt = detail.renews_at ? new Date(detail.renews_at).toLocaleString() : null;
            const actionUrl = detail.action_url || (detail.code ? '/subscribe' : null);
            const actionLabel = detail.action_label || 'Manage subscription';
            const statusCode = detail.status;

            const metaItems = [];
            if (runsRemaining !== null) {
                metaItems.push(`Runs remaining: <strong>${escapeHtml(String(runsRemaining))}</strong>`);
            }
            if (renewsAt) {
                metaItems.push(`Renews: <strong>${escapeHtml(renewsAt)}</strong>`);
            }
            if (statusCode) {
                metaItems.push(`Status: <strong>${escapeHtml(String(statusCode))}</strong>`);
            }

            const metaHtml = metaItems.length
                ? `<div class="result-meta">${metaItems.join('<span aria-hidden="true">•</span>')}</div>`
                : '';

            const safeActionUrl = actionUrl ? encodeURI(actionUrl) : null;
            const ctaHtml = safeActionUrl
                ? `<div class="result-cta"><a class="cta-button" href="${safeActionUrl}">${escapeHtml(actionLabel)}</a></div>`
                : '';

            technicalContent.innerHTML = `
                <div class="result-item error">
                    <div class="result-title">Analysis Unavailable</div>
                    <div class="result-content">${escapeHtml(errorText)}</div>
                    ${metaHtml}
                    ${ctaHtml}
                </div>
            ` + LEGAL_NOTE_HTML;

            if (safeActionUrl && (detail.code === 'subscription_required' || detail.code === 'quota_exhausted')) {
                setTimeout(() => {
                    window.location.href = safeActionUrl;
                }, 900);
            }
        }
        function showTab(tabName, evt) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`${tabName}Content`).classList.add('active');
            if (evt && evt.currentTarget) {
                evt.currentTarget.classList.add('active');
            }
        }
        // Polling function for async AI analysis
        async function pollAiAnalysis({
            jobId,
            includeAi,
            includePrincipal,
            aiContent,
            principalTab,
            principalPlanContent,
            resultTabs,
        }) {
            let attempts = 0;
            const maxAttempts = 40; // ~2 minutes if interval is 3s
            const intervalMs = 3000;

            if (includeAi && aiContent) {
                aiContent.innerHTML = `<div class="loading"><div class="spinner"></div><p>AI analysis is running... (Job ID: ${jobId})</p></div>`;
            }
            if (includePrincipal && principalPlanContent) {
                principalPlanContent.innerHTML = `<div class="loading"><div class="spinner"></div><p>Multi-agent strategy is being prepared...</p></div>`;
            }
            if ((includeAi || includePrincipal) && principalTab) {
                principalTab.style.display = 'block';
            }
            if (resultTabs) {
                resultTabs.classList.remove('hidden');
            }
            async function poll() {
                attempts++;
                try {
                    const resp = await fetch(`/api/ai-analysis-result/${jobId}`);
                    if (resp.ok) {
                        const result = await resp.json();
                        if (result && result.success && result.status === 'done') {
                            const payload = result.result || {};
                            if (includeAi && aiContent && Object.prototype.hasOwnProperty.call(payload, 'ai_analysis')) {
                                displayAiAnalysis(payload.ai_analysis);
                            }
                            if (includePrincipal && principalTab && Object.prototype.hasOwnProperty.call(payload, 'principal_plan')) {
                                const hasPlan = displayPrincipalPlan(payload.principal_plan);
                                if (hasPlan) {
                                    principalTab.style.display = 'block';
                                }
                            }
                            return;
                        }
                        if (result && result.status === 'error') {
                            const rawError = (result.error || '').toString();
                            const isTimeout = rawError.toLowerCase().includes('timeout');
                            const friendlyMessage = isTimeout
                                ? 'Our trading wizard took longer than expected. Give it another go in a moment—Principal Agent is already on the case!'
                                : rawError || 'Our agent tripped over a market banana peel. Please try again soon!';
                            if (includeAi && aiContent) {
                                aiContent.innerHTML = `<div class="result-item error"><div class="result-title">AI Analysis Paused</div><div class="result-content">${escapeHtml(friendlyMessage)}</div></div>${LEGAL_NOTE_HTML}`;
                            }
                            if (includePrincipal && principalPlanContent) {
                                principalPlanContent.innerHTML = `<div class="result-item error"><div class="result-title">Strategy Still Brewing</div><div class="result-content">${escapeHtml(friendlyMessage)}</div></div>${LEGAL_NOTE_HTML}`;
                            }
                            return;
                        }
                    }
                } catch (err) {
                    // Optionally show error in aiContent
                }
                if (attempts < maxAttempts) {
                    setTimeout(poll, intervalMs);
                } else {
                    const timeoutMessage = 'Our agent is working hard but needed a breather. Please try again shortly—Principal Agent will keep an eye on it!';
                    if (includeAi && aiContent) {
                        aiContent.innerHTML = `<div class="result-item error"><div class="result-title">AI Analysis Timeout</div><div class="result-content">${escapeHtml(timeoutMessage)}</div></div>${LEGAL_NOTE_HTML}`;
                    }
                    if (includePrincipal && principalPlanContent) {
                        principalPlanContent.innerHTML = `<div class="result-item error"><div class="result-title">Strategy Timeout</div><div class="result-content">${escapeHtml(timeoutMessage)}</div></div>${LEGAL_NOTE_HTML}`;
                    }
                }
            }
            poll();
        }
        // To hide by default, add class="tabs hidden" in HTML and define .hidden in your CSS:
        // .hidden { display: none !important;}
    </script>
    {% include "_contact_widget.html" %}
</body>
</html>